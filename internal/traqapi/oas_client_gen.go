// Code generated by ogen, DO NOT EDIT.

package traqapi

import (
	"context"
	"fmt"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ActivateBot invokes activateBot operation.
	//
	// 指定したBOTを有効化します。
	// 対象のBOTの管理権限が必要です。.
	//
	// POST /bots/{botId}/actions/activate
	ActivateBot(ctx context.Context, params ActivateBotParams) (ActivateBotRes, error)
	// AddMessageStamp invokes addMessageStamp operation.
	//
	// 指定したメッセージに指定したスタンプを押します。.
	//
	// POST /messages/{messageId}/stamps/{stampId}
	AddMessageStamp(ctx context.Context, request OptPostMessageStampRequest, params AddMessageStampParams) (AddMessageStampRes, error)
	// AddMyStar invokes addMyStar operation.
	//
	// 指定したチャンネルをスターチャンネルに追加します。
	// スター済みのチャンネルIDを指定した場合、204を返します。
	// 不正なチャンネルIDを指定した場合、400を返します。.
	//
	// POST /users/me/stars
	AddMyStar(ctx context.Context, request OptPostStarRequest) (AddMyStarRes, error)
	// AddMyUserTag invokes addMyUserTag operation.
	//
	// 自分に新しくタグを追加します。.
	//
	// POST /users/me/tags
	AddMyUserTag(ctx context.Context, request OptPostUserTagRequest) (AddMyUserTagRes, error)
	// AddUserGroupAdmin invokes addUserGroupAdmin operation.
	//
	// 指定したグループに管理者を追加します。
	// 対象のユーザーグループの管理者権限が必要です。.
	//
	// POST /groups/{groupId}/admins
	AddUserGroupAdmin(ctx context.Context, request OptPostUserGroupAdminRequest, params AddUserGroupAdminParams) (AddUserGroupAdminRes, error)
	// AddUserGroupMember invokes addUserGroupMember operation.
	//
	// 指定したグループにメンバーを追加します。
	// 対象のユーザーグループの管理者権限が必要です。.
	//
	// POST /groups/{groupId}/members
	AddUserGroupMember(ctx context.Context, request OptAddUserGroupMemberReq, params AddUserGroupMemberParams) (AddUserGroupMemberRes, error)
	// AddUserTag invokes addUserTag operation.
	//
	// 指定したユーザーに指定したタグを追加します。
	// Webhookユーザーにタグを追加することは出来ません。.
	//
	// POST /users/{userId}/tags
	AddUserTag(ctx context.Context, request OptPostUserTagRequest, params AddUserTagParams) (AddUserTagRes, error)
	// ChangeMyNotifyCitation invokes changeMyNotifyCitation operation.
	//
	// メッセージ引用通知の設定情報を変更します.
	//
	// PUT /users/me/settings/notify-citation
	ChangeMyNotifyCitation(ctx context.Context, request OptPutNotifyCitationRequest) (ChangeMyNotifyCitationRes, error)
	// ChangeMyPassword invokes changeMyPassword operation.
	//
	// 自身のパスワードを変更します。.
	//
	// PUT /users/me/password
	ChangeMyPassword(ctx context.Context, request OptPutMyPasswordRequest) (ChangeMyPasswordRes, error)
	// ChangeParticipantRole invokes changeParticipantRole operation.
	//
	// ルーム内の参加者の発言権限を変更します。.
	//
	// PATCH /qall/rooms/{roomId}/participants
	ChangeParticipantRole(ctx context.Context, request []QallParticipantRequest, params ChangeParticipantRoleParams) (ChangeParticipantRoleRes, error)
	// ChangeStampImage invokes changeStampImage operation.
	//
	// 指定したスタンプの画像を変更します。.
	//
	// PUT /stamps/{stampId}/image
	ChangeStampImage(ctx context.Context, request OptChangeStampImageReq, params ChangeStampImageParams) (ChangeStampImageRes, error)
	// ChangeUserPassword invokes changeUserPassword operation.
	//
	// 指定したユーザーのパスワードを変更します。
	// 管理者権限が必要です。.
	//
	// PUT /users/{userId}/password
	ChangeUserPassword(ctx context.Context, request OptPutUserPasswordRequest, params ChangeUserPasswordParams) (ChangeUserPasswordRes, error)
	// ClipMessage invokes clipMessage operation.
	//
	// 指定したメッセージを指定したクリップフォルダに追加します。.
	//
	// POST /clip-folders/{folderId}/messages
	ClipMessage(ctx context.Context, request OptPostClipFolderMessageRequest, params ClipMessageParams) (ClipMessageRes, error)
	// ConnectBotWS invokes connectBotWS operation.
	//
	// # BOT WebSocketプロトコル
	// ## 送信
	// `コマンド:引数1:引数2:...`
	// のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できます。
	// ### `rtcstate`コマンド
	// 自分のWebRTC状態を変更します。
	// 他のコネクションが既に状態を保持している場合、変更することができません。
	// `rtcstate:{チャンネルID}:({状態}:{セッションID})*`
	// チャンネルIDにnullもしくは空文字を指定するか、状態にnullもしくは空文字を指定した場合、WebRTC状態はリセットされます。
	// `rtcstate:null`, `rtcstate:`, `rtcstate:channelId:null`, `rtcstate:channelId:`
	// コネクションが切断された場合、自分のWebRTC状態はリセットされます。
	// ## 受信
	// TextMessageとして各種イベントが`type`、`reqId`、`body`を持つJSONとして非同期に送られます。
	// `body`の内容はHTTP Modeの場合のRequest Bodyと同様です。
	// 例外として`ERROR`イベントは`reqId`を持ちません。
	// 例: PINGイベント
	// `{"type":"PING","reqId":"requestId","body":{"eventTime":"2019-05-07T04:50:48.582586882Z"}}`
	// ### `ERROR`
	// コマンドの引数が不正などの理由でコマンドが受理されなかった場合に送られます。
	// 非同期に送られるため、必ずしもコマンドとの対応関係を確定できないことに注意してください。
	// 本番環境ではERRORが送られないようにすることが望ましいです。
	// `{"type":"ERROR","body":"message"}`.
	//
	// GET /bots/ws
	ConnectBotWS(ctx context.Context) error
	// CreateBot invokes createBot operation.
	//
	// BOTを作成します。
	// 作成後に購読イベントの設定を行う必要があります。
	// さらにHTTP Modeの場合はアクティベーションを行う必要があります。.
	//
	// POST /bots
	CreateBot(ctx context.Context, request OptPostBotRequest) (CreateBotRes, error)
	// CreateChannel invokes createChannel operation.
	//
	// チャンネルを作成します。
	// 階層が6以上になるチャンネルは作成できません。.
	//
	// POST /channels
	CreateChannel(ctx context.Context, request OptPostChannelRequest) (CreateChannelRes, error)
	// CreateClient invokes createClient operation.
	//
	// OAuth2クライアントを作成します。.
	//
	// POST /clients
	CreateClient(ctx context.Context, request OptPostClientRequest) (CreateClientRes, error)
	// CreateClipFolder invokes createClipFolder operation.
	//
	// クリップフォルダを作成します。
	// 既にあるフォルダと同名のフォルダを作成することは可能です。.
	//
	// POST /clip-folders
	CreateClipFolder(ctx context.Context, request OptPostClipFolderRequest) (CreateClipFolderRes, error)
	// CreatePin invokes createPin operation.
	//
	// 指定したメッセージをピン留めします。
	// アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。.
	//
	// POST /messages/{messageId}/pin
	CreatePin(ctx context.Context, params CreatePinParams) (CreatePinRes, error)
	// CreateStampPalette invokes createStampPalette operation.
	//
	// スタンプパレットを作成します。.
	//
	// POST /stamp-palettes
	CreateStampPalette(ctx context.Context, request OptPostStampPaletteRequest) (CreateStampPaletteRes, error)
	// CreateUser invokes createUser operation.
	//
	// ユーザーを登録します。
	// 管理者権限が必要です。.
	//
	// POST /users
	CreateUser(ctx context.Context, request OptPostUserRequest) (CreateUserRes, error)
	// CreateUserGroup invokes createUserGroup operation.
	//
	// ユーザーグループを作成します。
	// 作成者は自動的にグループ管理者になります。.
	//
	// POST /groups
	CreateUserGroup(ctx context.Context, request OptPostUserGroupRequest) (CreateUserGroupRes, error)
	// CreateWebhook invokes createWebhook operation.
	//
	// Webhookを新規作成します。
	// `secret`が空文字の場合、insecureウェブフックが作成されます。.
	//
	// POST /webhooks
	CreateWebhook(ctx context.Context, request OptPostWebhookRequest) (CreateWebhookRes, error)
	// DeleteBot invokes deleteBot operation.
	//
	// 指定したBOTを削除します。
	// 対象のBOTの管理権限が必要です。.
	//
	// DELETE /bots/{botId}
	DeleteBot(ctx context.Context, params DeleteBotParams) (DeleteBotRes, error)
	// DeleteClient invokes deleteClient operation.
	//
	// 指定したOAuth2クライアントを削除します。
	// 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。.
	//
	// DELETE /clients/{clientId}
	DeleteClient(ctx context.Context, params DeleteClientParams) (DeleteClientRes, error)
	// DeleteClipFolder invokes deleteClipFolder operation.
	//
	// 指定したクリップフォルダを削除します。.
	//
	// DELETE /clip-folders/{folderId}
	DeleteClipFolder(ctx context.Context, params DeleteClipFolderParams) (DeleteClipFolderRes, error)
	// DeleteFile invokes deleteFile operation.
	//
	// 指定したファイルを削除します。
	// 指定したファイルの削除権限が必要です。.
	//
	// DELETE /files/{fileId}
	DeleteFile(ctx context.Context, params DeleteFileParams) (DeleteFileRes, error)
	// DeleteMessage invokes deleteMessage operation.
	//
	// 指定したメッセージを削除します。
	// 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
	// アーカイブされているチャンネルのメッセージを編集することは出来ません。.
	//
	// DELETE /messages/{messageId}
	DeleteMessage(ctx context.Context, params DeleteMessageParams) (DeleteMessageRes, error)
	// DeleteOgpCache invokes deleteOgpCache operation.
	//
	// 指定されたURLのOGP情報のキャッシュを削除します。.
	//
	// DELETE /ogp/cache
	DeleteOgpCache(ctx context.Context, params DeleteOgpCacheParams) (DeleteOgpCacheRes, error)
	// DeleteStamp invokes deleteStamp operation.
	//
	// 指定したスタンプを削除します。
	// 対象のスタンプの削除権限が必要です。.
	//
	// DELETE /stamps/{stampId}
	DeleteStamp(ctx context.Context, params DeleteStampParams) (DeleteStampRes, error)
	// DeleteStampPalette invokes deleteStampPalette operation.
	//
	// 指定したスタンプパレットを削除します。
	// 対象のスタンプパレットの管理権限が必要です。.
	//
	// DELETE /stamp-palettes/{paletteId}
	DeleteStampPalette(ctx context.Context, params DeleteStampPaletteParams) (DeleteStampPaletteRes, error)
	// DeleteUserGroup invokes deleteUserGroup operation.
	//
	// 指定したユーザーグループを削除します。
	// 対象のユーザーグループの管理者権限が必要です。.
	//
	// DELETE /groups/{groupId}
	DeleteUserGroup(ctx context.Context, params DeleteUserGroupParams) (DeleteUserGroupRes, error)
	// DeleteWebhook invokes deleteWebhook operation.
	//
	// 指定したWebhookを削除します。
	// Webhookによって投稿されたメッセージは削除されません。.
	//
	// DELETE /webhooks/{webhookId}
	DeleteWebhook(ctx context.Context, params DeleteWebhookParams) (DeleteWebhookRes, error)
	// DeleteWebhookMessage invokes DeleteWebhookMessage operation.
	//
	// Webhookの投稿メッセージを削除.
	//
	// DELETE /webhooks/:webhookID/messages/:messageID
	DeleteWebhookMessage(ctx context.Context, params DeleteWebhookMessageParams) (DeleteWebhookMessageRes, error)
	// EditBot invokes editBot operation.
	//
	// 指定したBOTの情報を変更します。
	// 対象のBOTの管理権限が必要です。
	// BOT開発者UUIDを変更した場合は、変更先ユーザーにBOT管理権限が移譲され、自分自身は権限を失います。.
	//
	// PATCH /bots/{botId}
	EditBot(ctx context.Context, request OptPatchBotRequest, params EditBotParams) (EditBotRes, error)
	// EditChannel invokes editChannel operation.
	//
	// 指定したチャンネルの情報を変更します。
	// 変更には権限が必要です。
	// ルートチャンネルに移動させる場合は、`parent`に`00000000-0000-0000-0000-000000000000`を指定してください。.
	//
	// PATCH /channels/{channelId}
	EditChannel(ctx context.Context, request OptPatchChannelRequest, params EditChannelParams) (EditChannelRes, error)
	// EditChannelSubscribers invokes editChannelSubscribers operation.
	//
	// 指定したチャンネルの通知購読者を編集します。
	// リクエストに含めなかったユーザーの通知購読状態は変更しません。
	// また、存在しないユーザーを指定した場合は無視されます。.
	//
	// PATCH /channels/{channelId}/subscribers
	EditChannelSubscribers(ctx context.Context, request OptPatchChannelSubscribersRequest, params EditChannelSubscribersParams) (EditChannelSubscribersRes, error)
	// EditChannelTopic invokes editChannelTopic operation.
	//
	// 指定したチャンネルのトピックを編集します。
	// アーカイブされているチャンネルのトピックは編集できません。.
	//
	// PUT /channels/{channelId}/topic
	EditChannelTopic(ctx context.Context, request OptPutChannelTopicRequest, params EditChannelTopicParams) (EditChannelTopicRes, error)
	// EditClient invokes editClient operation.
	//
	// 指定したOAuth2クライアントの情報を変更します。
	// 対象のクライアントの管理権限が必要です。
	// クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。.
	//
	// PATCH /clients/{clientId}
	EditClient(ctx context.Context, request OptPatchClientRequest, params EditClientParams) (EditClientRes, error)
	// EditClipFolder invokes editClipFolder operation.
	//
	// 指定したクリップフォルダの情報を編集します。.
	//
	// PATCH /clip-folders/{folderId}
	EditClipFolder(ctx context.Context, request OptPatchClipFolderRequest, params EditClipFolderParams) (EditClipFolderRes, error)
	// EditMe invokes editMe operation.
	//
	// 自身のユーザー情報を変更します。.
	//
	// PATCH /users/me
	EditMe(ctx context.Context, request OptPatchMeRequest) (EditMeRes, error)
	// EditMessage invokes editMessage operation.
	//
	// 指定したメッセージを編集します。
	// 自身が投稿したメッセージのみ編集することができます。
	// アーカイブされているチャンネルのメッセージを編集することは出来ません。.
	//
	// PUT /messages/{messageId}
	EditMessage(ctx context.Context, request OptPostMessageRequest, params EditMessageParams) (EditMessageRes, error)
	// EditMyUserTag invokes editMyUserTag operation.
	//
	// 自分の指定したタグの状態を変更します。.
	//
	// PATCH /users/me/tags/{tagId}
	EditMyUserTag(ctx context.Context, request OptPatchUserTagRequest, params EditMyUserTagParams) (EditMyUserTagRes, error)
	// EditStamp invokes editStamp operation.
	//
	// 指定したスタンプの情報を変更します。.
	//
	// PATCH /stamps/{stampId}
	EditStamp(ctx context.Context, request OptPatchStampRequest, params EditStampParams) (EditStampRes, error)
	// EditStampPalette invokes editStampPalette operation.
	//
	// 指定したスタンプパレットを編集します。
	// リクエストのスタンプの配列の順番は保存されて変更されます。
	// 対象のスタンプパレットの管理権限が必要です。.
	//
	// PATCH /stamp-palettes/{paletteId}
	EditStampPalette(ctx context.Context, request OptPatchStampPaletteRequest, params EditStampPaletteParams) (EditStampPaletteRes, error)
	// EditUser invokes editUser operation.
	//
	// 指定したユーザーの情報を変更します。
	// 管理者権限が必要です。.
	//
	// PATCH /users/{userId}
	EditUser(ctx context.Context, request OptPatchUserRequest, params EditUserParams) (EditUserRes, error)
	// EditUserGroup invokes editUserGroup operation.
	//
	// 指定したユーザーグループの情報を編集します。
	// 対象のユーザーグループの管理者権限が必要です。.
	//
	// PATCH /groups/{groupId}
	EditUserGroup(ctx context.Context, request OptPatchUserGroupRequest, params EditUserGroupParams) (EditUserGroupRes, error)
	// EditUserGroupMember invokes editUserGroupMember operation.
	//
	// 指定したユーザーグループ内の指定したユーザーの属性を編集します。
	// 対象のユーザーグループの管理者権限が必要です。.
	//
	// PATCH /groups/{groupId}/members/{userId}
	EditUserGroupMember(ctx context.Context, request OptPatchGroupMemberRequest, params EditUserGroupMemberParams) (EditUserGroupMemberRes, error)
	// EditUserTag invokes editUserTag operation.
	//
	// 指定したユーザーの指定したタグの状態を変更します。
	// 他人の状態は変更できません。.
	//
	// PATCH /users/{userId}/tags/{tagId}
	EditUserTag(ctx context.Context, request OptPatchUserTagRequest, params EditUserTagParams) (EditUserTagRes, error)
	// EditWebhook invokes editWebhook operation.
	//
	// 指定したWebhookの情報を変更します。.
	//
	// PATCH /webhooks/{webhookId}
	EditWebhook(ctx context.Context, request OptPatchWebhookRequest, params EditWebhookParams) (EditWebhookRes, error)
	// GetActivityTimeline invokes getActivityTimeline operation.
	//
	// パブリックチャンネルの直近の投稿メッセージを作成日時の降順で取得します。
	// `all`が`true`でない場合、購読チャンネルのみのタイムラインを取得します.
	//
	// GET /activity/timeline
	GetActivityTimeline(ctx context.Context, params GetActivityTimelineParams) (GetActivityTimelineRes, error)
	// GetBot invokes getBot operation.
	//
	// 指定したBOTのBOT情報を取得します。
	// BOT詳細情報を取得する場合は、対象のBOTの管理権限が必要です。.
	//
	// GET /bots/{botId}
	GetBot(ctx context.Context, params GetBotParams) (GetBotRes, error)
	// GetBotIcon invokes getBotIcon operation.
	//
	// 指定したBOTのアイコン画像を取得を取得します。.
	//
	// GET /bots/{botId}/icon
	GetBotIcon(ctx context.Context, params GetBotIconParams) (GetBotIconRes, error)
	// GetBotLogs invokes getBotLogs operation.
	//
	// 指定したBOTのイベントログを取得します。
	// 対象のBOTの管理権限が必要です。.
	//
	// GET /bots/{botId}/logs
	GetBotLogs(ctx context.Context, params GetBotLogsParams) (GetBotLogsRes, error)
	// GetBots invokes getBots operation.
	//
	// BOT情報のリストを取得します。
	// allを指定しない場合、自分が開発者のBOTのみを返します。.
	//
	// GET /bots
	GetBots(ctx context.Context, params GetBotsParams) ([]Bot, error)
	// GetChannel invokes getChannel operation.
	//
	// 指定したチャンネルの情報を取得します。.
	//
	// GET /channels/{channelId}
	GetChannel(ctx context.Context, params GetChannelParams) (GetChannelRes, error)
	// GetChannelBots invokes getChannelBots operation.
	//
	// 指定したチャンネルに参加しているBOTのリストを取得します。.
	//
	// GET /channels/{channelId}/bots
	GetChannelBots(ctx context.Context, params GetChannelBotsParams) (GetChannelBotsRes, error)
	// GetChannelPath invokes getChannelPath operation.
	//
	// 指定したチャンネルパスを取得.
	//
	// GET /channels/{channelId}/path
	GetChannelPath(ctx context.Context, params GetChannelPathParams) (GetChannelPathRes, error)
	// GetChannelPins invokes getChannelPins operation.
	//
	// 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。.
	//
	// GET /channels/{channelId}/pins
	GetChannelPins(ctx context.Context, params GetChannelPinsParams) (GetChannelPinsRes, error)
	// GetChannelStats invokes getChannelStats operation.
	//
	// 指定したチャンネルの統計情報を取得します。.
	//
	// GET /channels/{channelId}/stats
	GetChannelStats(ctx context.Context, params GetChannelStatsParams) (GetChannelStatsRes, error)
	// GetChannelSubscribers invokes getChannelSubscribers operation.
	//
	// 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。.
	//
	// GET /channels/{channelId}/subscribers
	GetChannelSubscribers(ctx context.Context, params GetChannelSubscribersParams) (GetChannelSubscribersRes, error)
	// GetChannelTopic invokes getChannelTopic operation.
	//
	// 指定したチャンネルのトピックを取得します。.
	//
	// GET /channels/{channelId}/topic
	GetChannelTopic(ctx context.Context, params GetChannelTopicParams) (GetChannelTopicRes, error)
	// GetChannelViewers invokes getChannelViewers operation.
	//
	// 指定したチャンネルの閲覧者のリストを取得します。.
	//
	// GET /channels/{channelId}/viewers
	GetChannelViewers(ctx context.Context, params GetChannelViewersParams) (GetChannelViewersRes, error)
	// GetChannels invokes getChannels operation.
	//
	// チャンネルのリストを取得します。.
	//
	// GET /channels
	GetChannels(ctx context.Context, params GetChannelsParams) (*ChannelList, error)
	// GetClient invokes getClient operation.
	//
	// 指定したOAuth2クライアントの情報を取得します。
	// 詳細情報の取得には対象のクライアントの管理権限が必要です。.
	//
	// GET /clients/{clientId}
	GetClient(ctx context.Context, params GetClientParams) (GetClientRes, error)
	// GetClients invokes getClients operation.
	//
	// 自身が開発者のOAuth2クライアントのリストを取得します。
	// `all`が`true`の場合、全開発者の全クライアントのリストを返します。.
	//
	// GET /clients
	GetClients(ctx context.Context, params GetClientsParams) ([]OAuth2Client, error)
	// GetClipFolder invokes getClipFolder operation.
	//
	// 指定したクリップフォルダの情報を取得します。.
	//
	// GET /clip-folders/{folderId}
	GetClipFolder(ctx context.Context, params GetClipFolderParams) (GetClipFolderRes, error)
	// GetClipFolders invokes getClipFolders operation.
	//
	// 自身が所有するクリップフォルダのリストを取得します。.
	//
	// GET /clip-folders
	GetClipFolders(ctx context.Context) ([]ClipFolder, error)
	// GetClips invokes getClips operation.
	//
	// 指定したフォルダ内のクリップのリストを取得します。
	// `order`を指定しない場合、クリップした日時の新しい順で返されます。.
	//
	// GET /clip-folders/{folderId}/messages
	GetClips(ctx context.Context, params GetClipsParams) (GetClipsRes, error)
	// GetDirectMessages invokes getDirectMessages operation.
	//
	// 指定したユーザーとのダイレクトメッセージのリストを取得します。.
	//
	// GET /users/{userId}/messages
	GetDirectMessages(ctx context.Context, params GetDirectMessagesParams) (GetDirectMessagesRes, error)
	// GetFile invokes getFile operation.
	//
	// 指定したファイル本体を取得します。
	// 指定したファイルへのアクセス権限が必要です。.
	//
	// GET /files/{fileId}
	GetFile(ctx context.Context, params GetFileParams) (GetFileRes, error)
	// GetFileMeta invokes getFileMeta operation.
	//
	// 指定したファイルのメタ情報を取得します。
	// 指定したファイルへのアクセス権限が必要です。.
	//
	// GET /files/{fileId}/meta
	GetFileMeta(ctx context.Context, params GetFileMetaParams) (GetFileMetaRes, error)
	// GetFiles invokes getFiles operation.
	//
	// 指定したクエリでファイルメタのリストを取得します。
	// クエリパラメータ`channelId`, `mine`の少なくともいずれかが必須です。.
	//
	// GET /files
	GetFiles(ctx context.Context, params GetFilesParams) (GetFilesRes, error)
	// GetLiveKitToken invokes getLiveKitToken operation.
	//
	// 指定したルームに参加するためのLiveKitトークンを取得します。.
	//
	// GET /qall/token
	GetLiveKitToken(ctx context.Context, params GetLiveKitTokenParams) (GetLiveKitTokenRes, error)
	// GetMe invokes getMe operation.
	//
	// 自身のユーザー詳細情報を取得します。.
	//
	// GET /users/me
	GetMe(ctx context.Context) (*MyUserDetail, error)
	// GetMessage invokes getMessage operation.
	//
	// 指定したメッセージを取得します。.
	//
	// GET /messages/{messageId}
	GetMessage(ctx context.Context, params GetMessageParams) (GetMessageRes, error)
	// GetMessageClips invokes getMessageClips operation.
	//
	// 対象のメッセージの自分のクリップの一覧を返します。.
	//
	// GET /messages/{messageId}/clips
	GetMessageClips(ctx context.Context, params GetMessageClipsParams) (GetMessageClipsRes, error)
	// GetMessageStamps invokes getMessageStamps operation.
	//
	// 指定したメッセージに押されているスタンプのリストを取得します。.
	//
	// GET /messages/{messageId}/stamps
	GetMessageStamps(ctx context.Context, params GetMessageStampsParams) (GetMessageStampsRes, error)
	// GetMessages invokes getMessages operation.
	//
	// 指定したチャンネルのメッセージのリストを取得します。.
	//
	// GET /channels/{channelId}/messages
	GetMessages(ctx context.Context, params GetMessagesParams) (GetMessagesRes, error)
	// GetMyChannelSubscriptions invokes getMyChannelSubscriptions operation.
	//
	// 自身のチャンネル購読状態を取得します。.
	//
	// GET /users/me/subscriptions
	GetMyChannelSubscriptions(ctx context.Context) ([]UserSubscribeState, error)
	// GetMyExternalAccounts invokes getMyExternalAccounts operation.
	//
	// 自分に紐付けられている外部ログインアカウント一覧を取得します。.
	//
	// GET /users/me/ex-accounts
	GetMyExternalAccounts(ctx context.Context) ([]ExternalProviderUser, error)
	// GetMyIcon invokes getMyIcon operation.
	//
	// 自分のアイコン画像を取得します。.
	//
	// GET /users/me/icon
	GetMyIcon(ctx context.Context) (GetMyIconRes, error)
	// GetMyNotifyCitation invokes getMyNotifyCitation operation.
	//
	// メッセージ引用通知の設定情報を変更します。.
	//
	// GET /users/me/settings/notify-citation
	GetMyNotifyCitation(ctx context.Context) (*GetNotifyCitation, error)
	// GetMyQRCode invokes getMyQRCode operation.
	//
	// 自身のQRコードを取得します。
	// 返されたQRコードまたはトークンは、発行後の5分間のみ有効です.
	//
	// GET /users/me/qr-code
	GetMyQRCode(ctx context.Context, params GetMyQRCodeParams) (GetMyQRCodeRes, error)
	// GetMySessions invokes getMySessions operation.
	//
	// 自分のログインセッションのリストを取得します。.
	//
	// GET /users/me/sessions
	GetMySessions(ctx context.Context) ([]LoginSession, error)
	// GetMyStampHistory invokes getMyStampHistory operation.
	//
	// 自分のスタンプ履歴を最大100件まで取得します。
	// 結果は降順で返されます。
	// このAPIが返すスタンプ履歴は厳密な履歴ではありません。.
	//
	// GET /users/me/stamp-history
	GetMyStampHistory(ctx context.Context, params GetMyStampHistoryParams) ([]StampHistoryEntry, error)
	// GetMyStars invokes getMyStars operation.
	//
	// 自分がスターしているチャンネルのUUIDの配列を取得します。.
	//
	// GET /users/me/stars
	GetMyStars(ctx context.Context) ([]uuid.UUID, error)
	// GetMyTokens invokes getMyTokens operation.
	//
	// 有効な自分に発行されたOAuth2トークンのリストを取得します。.
	//
	// GET /users/me/tokens
	GetMyTokens(ctx context.Context) ([]ActiveOAuth2Token, error)
	// GetMyUnreadChannels invokes getMyUnreadChannels operation.
	//
	// 自分が現在未読のチャンネルの未読情報を取得します。.
	//
	// GET /users/me/unread
	GetMyUnreadChannels(ctx context.Context) ([]UnreadChannel, error)
	// GetMyUserTags invokes getMyUserTags operation.
	//
	// 自分に付けられているタグの配列を取得します。.
	//
	// GET /users/me/tags
	GetMyUserTags(ctx context.Context) ([]UserTag, error)
	// GetMyViewStates invokes getMyViewStates operation.
	//
	// 自身のチャンネル閲覧状態一覧を取得します。.
	//
	// GET /users/me/view-states
	GetMyViewStates(ctx context.Context) ([]MyChannelViewState, error)
	// GetOAuth2Authorize invokes getOAuth2Authorize operation.
	//
	// OAuth2 認可エンドポイント.
	//
	// GET /oauth2/authorize
	GetOAuth2Authorize(ctx context.Context, params GetOAuth2AuthorizeParams) (GetOAuth2AuthorizeRes, error)
	// GetOIDCUserInfo invokes getOIDCUserInfo operation.
	//
	// OIDCトークンを用いてユーザー詳細を取得します。
	// OIDC UserInfo Endpointです。.
	//
	// GET /users/me/oidc
	GetOIDCUserInfo(ctx context.Context) (*OIDCUserInfo, error)
	// GetOgp invokes getOgp operation.
	//
	// 指定されたURLのOGP情報を取得します。
	// 指定されたURLに対するOGP情報が見つからなかった場合、typeがemptyに設定された空のOGP情報を返します。.
	//
	// GET /ogp
	GetOgp(ctx context.Context, params GetOgpParams) (GetOgpRes, error)
	// GetOnlineUsers invokes getOnlineUsers operation.
	//
	// 現在オンラインな(SSEまたはWSが接続中)ユーザーのUUIDのリストを返します。.
	//
	// GET /activity/onlines
	GetOnlineUsers(ctx context.Context) ([]string, error)
	// GetPin invokes getPin operation.
	//
	// 指定したメッセージのピン留め情報を取得します。.
	//
	// GET /messages/{messageId}/pin
	GetPin(ctx context.Context, params GetPinParams) (GetPinRes, error)
	// GetPublicUserIcon invokes getPublicUserIcon operation.
	//
	// ユーザーのアイコン画像を取得します。.
	//
	// GET /public/icon/{username}
	GetPublicUserIcon(ctx context.Context, params GetPublicUserIconParams) (GetPublicUserIconRes, error)
	// GetQallEndpoints invokes getQallEndpoints operation.
	//
	// 接続可能なLiveKitエンドポイントを取得します。.
	//
	// GET /qall/endpoints
	GetQallEndpoints(ctx context.Context) (GetQallEndpointsRes, error)
	// GetRoomMetadata invokes getRoomMetadata operation.
	//
	// ルームのメタデータを取得します。.
	//
	// GET /qall/rooms/{roomId}/metadata
	GetRoomMetadata(ctx context.Context, params GetRoomMetadataParams) (GetRoomMetadataRes, error)
	// GetRooms invokes getRooms operation.
	//
	// 現在存在する(またはアクティブな)ルームと、そのルームに所属している参加者情報を取得します。.
	//
	// GET /qall/rooms
	GetRooms(ctx context.Context) (GetRoomsRes, error)
	// GetServerVersion invokes getServerVersion operation.
	//
	// サーバーバージョン及びサーバーフラグ情報を取得します。.
	//
	// GET /version
	GetServerVersion(ctx context.Context) (*Version, error)
	// GetSoundboardList invokes getSoundboardList operation.
	//
	// DBに保存されたサウンドボード情報を取得します。   各アイテムには
	// soundId, soundName, stampId が含まれます。.
	//
	// GET /qall/soundboard
	GetSoundboardList(ctx context.Context) (GetSoundboardListRes, error)
	// GetStamp invokes getStamp operation.
	//
	// 指定したスタンプの情報を取得します。.
	//
	// GET /stamps/{stampId}
	GetStamp(ctx context.Context, params GetStampParams) (GetStampRes, error)
	// GetStampImage invokes getStampImage operation.
	//
	// 指定したIDのスタンプ画像を返します。.
	//
	// GET /stamps/{stampId}/image
	GetStampImage(ctx context.Context, params GetStampImageParams) (GetStampImageRes, error)
	// GetStampPalette invokes getStampPalette operation.
	//
	// 指定したスタンプパレットの情報を取得します。.
	//
	// GET /stamp-palettes/{paletteId}
	GetStampPalette(ctx context.Context, params GetStampPaletteParams) (GetStampPaletteRes, error)
	// GetStampPalettes invokes getStampPalettes operation.
	//
	// 自身が所有しているスタンプパレットのリストを取得します。.
	//
	// GET /stamp-palettes
	GetStampPalettes(ctx context.Context) ([]StampPalette, error)
	// GetStampStats invokes getStampStats operation.
	//
	// 指定したスタンプの統計情報を取得します。.
	//
	// GET /stamps/{stampId}/stats
	GetStampStats(ctx context.Context, params GetStampStatsParams) (GetStampStatsRes, error)
	// GetStamps invokes getStamps operation.
	//
	// スタンプのリストを取得します。.
	//
	// GET /stamps
	GetStamps(ctx context.Context, params GetStampsParams) ([]StampWithThumbnail, error)
	// GetTag invokes getTag operation.
	//
	// 指定したタグの情報を取得します。.
	//
	// GET /tags/{tagId}
	GetTag(ctx context.Context, params GetTagParams) (GetTagRes, error)
	// GetThumbnailImage invokes getThumbnailImage operation.
	//
	// 指定したファイルのサムネイル画像を取得します。
	// 指定したファイルへのアクセス権限が必要です。.
	//
	// GET /files/{fileId}/thumbnail
	GetThumbnailImage(ctx context.Context, params GetThumbnailImageParams) (GetThumbnailImageRes, error)
	// GetUser invokes getUser operation.
	//
	// 指定したユーザーの詳細情報を取得します。.
	//
	// GET /users/{userId}
	GetUser(ctx context.Context, params GetUserParams) (GetUserRes, error)
	// GetUserDMChannel invokes getUserDMChannel operation.
	//
	// 指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。
	// ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。.
	//
	// GET /users/{userId}/dm-channel
	GetUserDMChannel(ctx context.Context, params GetUserDMChannelParams) (GetUserDMChannelRes, error)
	// GetUserGroup invokes getUserGroup operation.
	//
	// 指定したユーザーグループの情報を取得します。.
	//
	// GET /groups/{groupId}
	GetUserGroup(ctx context.Context, params GetUserGroupParams) (GetUserGroupRes, error)
	// GetUserGroupAdmins invokes getUserGroupAdmins operation.
	//
	// 指定したグループの管理者のリストを取得します。.
	//
	// GET /groups/{groupId}/admins
	GetUserGroupAdmins(ctx context.Context, params GetUserGroupAdminsParams) (GetUserGroupAdminsRes, error)
	// GetUserGroupMembers invokes getUserGroupMembers operation.
	//
	// 指定したグループのメンバーのリストを取得します。.
	//
	// GET /groups/{groupId}/members
	GetUserGroupMembers(ctx context.Context, params GetUserGroupMembersParams) (GetUserGroupMembersRes, error)
	// GetUserGroups invokes getUserGroups operation.
	//
	// ユーザーグループのリストを取得します。.
	//
	// GET /groups
	GetUserGroups(ctx context.Context) ([]UserGroup, error)
	// GetUserIcon invokes getUserIcon operation.
	//
	// 指定したユーザーのアイコン画像を取得します。.
	//
	// GET /users/{userId}/icon
	GetUserIcon(ctx context.Context, params GetUserIconParams) (GetUserIconRes, error)
	// GetUserSettings invokes getUserSettings operation.
	//
	// ユーザー設定を取得します。.
	//
	// GET /users/me/settings
	GetUserSettings(ctx context.Context) (*UserSettings, error)
	// GetUserStats invokes getUserStats operation.
	//
	// 指定したユーザーの統計情報を取得します。.
	//
	// GET /users/{userId}/stats
	GetUserStats(ctx context.Context, params GetUserStatsParams) (GetUserStatsRes, error)
	// GetUserTags invokes getUserTags operation.
	//
	// 指定したユーザーのタグリストを取得します。.
	//
	// GET /users/{userId}/tags
	GetUserTags(ctx context.Context, params GetUserTagsParams) (GetUserTagsRes, error)
	// GetUsers invokes getUsers operation.
	//
	// ユーザーのリストを取得します。
	// `include-suspended`を指定しない場合、レスポンスにはユーザーアカウント状態が"1: 有効"であるユーザーのみが含まれます。
	// `include-suspended`と`name`を同時に指定することはできません。.
	//
	// GET /users
	GetUsers(ctx context.Context, params GetUsersParams) (GetUsersRes, error)
	// GetWebRTCState invokes getWebRTCState operation.
	//
	// 現在のWebRTC状態を取得します。.
	//
	// GET /webrtc/state
	GetWebRTCState(ctx context.Context) (WebRTCUserStates, error)
	// GetWebhook invokes getWebhook operation.
	//
	// 指定したWebhookの詳細を取得します。.
	//
	// GET /webhooks/{webhookId}
	GetWebhook(ctx context.Context, params GetWebhookParams) (GetWebhookRes, error)
	// GetWebhookIcon invokes getWebhookIcon operation.
	//
	// 指定したWebhookのアイコン画像を取得します.
	//
	// GET /webhooks/{webhookId}/icon
	GetWebhookIcon(ctx context.Context, params GetWebhookIconParams) (GetWebhookIconRes, error)
	// GetWebhookMessages invokes getWebhookMessages operation.
	//
	// 指定されたWebhookが投稿したメッセージのリストを返します。.
	//
	// GET /webhooks/{webhookId}/messages
	GetWebhookMessages(ctx context.Context, params GetWebhookMessagesParams) (GetWebhookMessagesRes, error)
	// GetWebhooks invokes getWebhooks operation.
	//
	// Webhookのリストを取得します。
	// allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。.
	//
	// GET /webhooks
	GetWebhooks(ctx context.Context, params GetWebhooksParams) ([]Webhook, error)
	// InactivateBot invokes inactivateBot operation.
	//
	// 指定したBOTを無効化します。対象のBOTの管理権限が必要です。.
	//
	// POST /bots/{botId}/actions/inactivate
	InactivateBot(ctx context.Context, params InactivateBotParams) (InactivateBotRes, error)
	// LetBotJoinChannel invokes letBotJoinChannel operation.
	//
	// 指定したBOTを指定したチャンネルに参加させます。
	// チャンネルに参加したBOTは、そのチャンネルの各種イベントを受け取るようになります。
	// 対象のBOTの管理権限が必要です。.
	//
	// POST /bots/{botId}/actions/join
	LetBotJoinChannel(ctx context.Context, request OptPostBotActionJoinRequest, params LetBotJoinChannelParams) (LetBotJoinChannelRes, error)
	// LetBotLeaveChannel invokes letBotLeaveChannel operation.
	//
	// 指定したBOTを指定したチャンネルから退出させます。
	// 対象のBOTの管理権限が必要です。.
	//
	// POST /bots/{botId}/actions/leave
	LetBotLeaveChannel(ctx context.Context, request OptPostBotActionLeaveRequest, params LetBotLeaveChannelParams) (LetBotLeaveChannelRes, error)
	// LinkExternalAccount invokes linkExternalAccount operation.
	//
	// 自分に外部ログインアカウントを紐付けます。
	// 指定した`providerName`がサーバー側で有効である必要があります。
	// リクエストが受理された場合、外部サービスの認証画面にリダイレクトされ、認証される必要があります。.
	//
	// POST /users/me/ex-accounts/link
	LinkExternalAccount(ctx context.Context, request OptPostLinkExternalAccount) (LinkExternalAccountRes, error)
	// Login invokes login operation.
	//
	// ログインします。.
	//
	// POST /login
	Login(ctx context.Context, request OptPostLoginRequest, params LoginParams) (LoginRes, error)
	// Logout invokes logout operation.
	//
	// ログアウトします。.
	//
	// POST /logout
	Logout(ctx context.Context, params LogoutParams) (LogoutRes, error)
	// PostDirectMessage invokes postDirectMessage operation.
	//
	// 指定したユーザーにダイレクトメッセージを送信します。.
	//
	// POST /users/{userId}/messages
	PostDirectMessage(ctx context.Context, request OptPostMessageRequest, params PostDirectMessageParams) (PostDirectMessageRes, error)
	// PostFile invokes postFile operation.
	//
	// 指定したチャンネルにファイルをアップロードします。
	// アーカイブされているチャンネルにはアップロード出来ません。.
	//
	// POST /files
	PostFile(ctx context.Context, request OptPostFileRequestMultipart) (PostFileRes, error)
	// PostMessage invokes postMessage operation.
	//
	// 指定したチャンネルにメッセージを投稿します。
	// embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
	// アーカイブされているチャンネルに投稿することはできません。.
	//
	// POST /channels/{channelId}/messages
	PostMessage(ctx context.Context, request OptPostMessageRequest, params PostMessageParams) (PostMessageRes, error)
	// PostOAuth2Authorize invokes postOAuth2Authorize operation.
	//
	// OAuth2 認可エンドポイント.
	//
	// POST /oauth2/authorize
	PostOAuth2Authorize(ctx context.Context, request *OAuth2Authorization) (PostOAuth2AuthorizeRes, error)
	// PostOAuth2AuthorizeDecide invokes postOAuth2AuthorizeDecide operation.
	//
	// OAuth2 認可承諾.
	//
	// POST /oauth2/authorize/decide
	PostOAuth2AuthorizeDecide(ctx context.Context, request *OAuth2Decide) (PostOAuth2AuthorizeDecideRes, error)
	// PostOAuth2Token invokes postOAuth2Token operation.
	//
	// OAuth2 トークンエンドポイント.
	//
	// POST /oauth2/token
	PostOAuth2Token(ctx context.Context, request *PostOAuth2Token) (PostOAuth2TokenRes, error)
	// PostSoundboard invokes postSoundboard operation.
	//
	// 15秒程度の短い音声ファイルを multipart/form-data
	// で送信し、S3(互換ストレージ)にアップロードします。
	// クライアントは「soundName」というフィールドを送信し、それをDBに保存して関連付けを行います。   また、サーバ側で soundId を自動生成し、S3のファイル名に使用します。.
	//
	// POST /qall/soundboard
	PostSoundboard(ctx context.Context, request *SoundboardUploadRequestMultipart) (PostSoundboardRes, error)
	// PostSoundboardPlay invokes postSoundboardPlay operation.
	//
	// S3上にある音声ファイルの署名付きURLを生成し、
	// Ingressを介して指定ルームに音声を流します。
	// 該当ルームに参加しているユーザであれば再生可能とします。.
	//
	// POST /qall/soundboard/play
	PostSoundboardPlay(ctx context.Context, request *SoundboardPlayRequest) (PostSoundboardPlayRes, error)
	// PostWebRTCAuthenticate invokes postWebRTCAuthenticate operation.
	//
	// Skyway WebRTC用の認証API.
	//
	// POST /webrtc/authenticate
	PostWebRTCAuthenticate(ctx context.Context, request OptPostWebRTCAuthenticateRequest) (PostWebRTCAuthenticateRes, error)
	// PostWebhook invokes postWebhook operation.
	//
	// Webhookにメッセージを投稿します。
	// secureなウェブフックに対しては`X-TRAQ-Signature`ヘッダーが必須です。
	// アーカイブされているチャンネルには投稿できません。.
	//
	// POST /webhooks/{webhookId}
	PostWebhook(ctx context.Context, request PostWebhookReq, params PostWebhookParams) (PostWebhookRes, error)
	// ReadChannel invokes readChannel operation.
	//
	// 自分が未読のチャンネルを既読にします。.
	//
	// DELETE /users/me/unread/{channelId}
	ReadChannel(ctx context.Context, params ReadChannelParams) error
	// RegisterFCMDevice invokes registerFCMDevice operation.
	//
	// 自身のFCMデバイスを登録します。.
	//
	// POST /users/me/fcm-device
	RegisterFCMDevice(ctx context.Context, request OptPostMyFCMDeviceRequest) (RegisterFCMDeviceRes, error)
	// ReissueBot invokes reissueBot operation.
	//
	// 指定したBOTの現在の各種トークンを無効化し、再発行を行います。
	// 対象のBOTの管理権限が必要です。.
	//
	// POST /bots/{botId}/actions/reissue
	ReissueBot(ctx context.Context, params ReissueBotParams) (ReissueBotRes, error)
	// RemoveMessageStamp invokes removeMessageStamp operation.
	//
	// 指定したメッセージから指定した自身が押したスタンプを削除します。.
	//
	// DELETE /messages/{messageId}/stamps/{stampId}
	RemoveMessageStamp(ctx context.Context, params RemoveMessageStampParams) (RemoveMessageStampRes, error)
	// RemoveMyStar invokes removeMyStar operation.
	//
	// 既にスターから削除されているチャンネルを指定した場合は204を返します。.
	//
	// DELETE /users/me/stars/{channelId}
	RemoveMyStar(ctx context.Context, params RemoveMyStarParams) error
	// RemoveMyUserTag invokes removeMyUserTag operation.
	//
	// 既に存在しないタグを削除しようとした場合は204を返します。.
	//
	// DELETE /users/me/tags/{tagId}
	RemoveMyUserTag(ctx context.Context, params RemoveMyUserTagParams) (RemoveMyUserTagRes, error)
	// RemovePin invokes removePin operation.
	//
	// 指定したメッセージのピン留めを外します。.
	//
	// DELETE /messages/{messageId}/pin
	RemovePin(ctx context.Context, params RemovePinParams) (RemovePinRes, error)
	// RemoveUserGroupAdmin invokes removeUserGroupAdmin operation.
	//
	// 指定したユーザーグループから指定した管理者を削除します。
	// 対象のユーザーグループの管理者権限が必要です。
	// グループから管理者が存在しなくなる場合は400エラーを返します。.
	//
	// DELETE /groups/{groupId}/admins/{userId}
	RemoveUserGroupAdmin(ctx context.Context, params RemoveUserGroupAdminParams) (RemoveUserGroupAdminRes, error)
	// RemoveUserGroupMember invokes removeUserGroupMember operation.
	//
	// 指定したユーザーグループから指定したユーザーを削除します。
	// 既にグループから削除されているメンバーを指定した場合は204を返します。
	// 対象のユーザーグループの管理者権限が必要です。.
	//
	// DELETE /groups/{groupId}/members/{userId}
	RemoveUserGroupMember(ctx context.Context, params RemoveUserGroupMemberParams) (RemoveUserGroupMemberRes, error)
	// RemoveUserGroupMembers invokes removeUserGroupMembers operation.
	//
	// 指定したグループから全てのメンバーを削除します。
	// 対象のユーザーグループの管理者権限が必要です。.
	//
	// DELETE /groups/{groupId}/members
	RemoveUserGroupMembers(ctx context.Context, params RemoveUserGroupMembersParams) (RemoveUserGroupMembersRes, error)
	// RemoveUserTag invokes removeUserTag operation.
	//
	// 既に存在しないタグを削除しようとした場合は204を返します。.
	//
	// DELETE /users/{userId}/tags/{tagId}
	RemoveUserTag(ctx context.Context, params RemoveUserTagParams) (RemoveUserTagRes, error)
	// RevokeClientTokens invokes revokeClientTokens operation.
	//
	// 自分が許可している指定したOAuthクライアントのアクセストークンを全てRevokeします。.
	//
	// DELETE /clients/{clientId}/tokens
	RevokeClientTokens(ctx context.Context, params RevokeClientTokensParams) (RevokeClientTokensRes, error)
	// RevokeMySession invokes revokeMySession operation.
	//
	// 指定した自分のセッションを無効化(ログアウト)します。
	// 既に存在しない・無効化されているセッションを指定した場合も`204`を返します。.
	//
	// DELETE /users/me/sessions/{sessionId}
	RevokeMySession(ctx context.Context, params RevokeMySessionParams) error
	// RevokeMyToken invokes revokeMyToken operation.
	//
	// 自分の指定したトークンの認可を取り消します。.
	//
	// DELETE /users/me/tokens/{tokenId}
	RevokeMyToken(ctx context.Context, params RevokeMyTokenParams) (RevokeMyTokenRes, error)
	// RevokeOAuth2Token invokes revokeOAuth2Token operation.
	//
	// OAuth2 トークン無効化エンドポイント.
	//
	// POST /oauth2/revoke
	RevokeOAuth2Token(ctx context.Context, request *OAuth2Revoke) error
	// SearchMessages invokes searchMessages operation.
	//
	// メッセージを検索します。.
	//
	// GET /messages
	SearchMessages(ctx context.Context, params SearchMessagesParams) (SearchMessagesRes, error)
	// SetChannelSubscribeLevel invokes setChannelSubscribeLevel operation.
	//
	// 自身の指定したチャンネルの購読レベルを設定します。.
	//
	// PUT /users/me/subscriptions/{channelId}
	SetChannelSubscribeLevel(ctx context.Context, request OptPutChannelSubscribeLevelRequest, params SetChannelSubscribeLevelParams) (SetChannelSubscribeLevelRes, error)
	// SetChannelSubscribers invokes setChannelSubscribers operation.
	//
	// 指定したチャンネルの通知購読者を設定します。
	// リクエストに含めなかったユーザーの通知購読状態はオフになります。
	// また、存在しないユーザーを指定した場合は無視されます。.
	//
	// PUT /channels/{channelId}/subscribers
	SetChannelSubscribers(ctx context.Context, request OptPutChannelSubscribersRequest, params SetChannelSubscribersParams) (SetChannelSubscribersRes, error)
	// UnclipMessage invokes unclipMessage operation.
	//
	// 指定したフォルダから指定したメッセージのクリップを除外します。
	// 既に外されているメッセージを指定した場合は204を返します。.
	//
	// DELETE /clip-folders/{folderId}/messages/{messageId}
	UnclipMessage(ctx context.Context, params UnclipMessageParams) (UnclipMessageRes, error)
	// UnlinkExternalAccount invokes unlinkExternalAccount operation.
	//
	// 自分に紐付けられている外部ログインアカウントの紐付けを解除します。.
	//
	// POST /users/me/ex-accounts/unlink
	UnlinkExternalAccount(ctx context.Context, request OptPostUnlinkExternalAccount) (UnlinkExternalAccountRes, error)
	// UpdateRoomMetadata invokes updateRoomMetadata operation.
	//
	// ルームのメタデータを更新します。.
	//
	// PATCH /qall/rooms/{roomId}/metadata
	UpdateRoomMetadata(ctx context.Context, request *QallMetadataRequest, params UpdateRoomMetadataParams) (UpdateRoomMetadataRes, error)
	// Ws invokes ws operation.
	//
	// # WebSocketプロトコル
	// ## 送信
	// `コマンド:引数1:引数2:...
	// `のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。
	// ### `viewstate`コマンド
	// このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。
	// 現時点では1つのセッションに対して1つのチャンネルしか設定できない。
	// `viewstate:{チャンネルID}:{閲覧状態}`
	// + チャンネルID: 対象のチャンネルID
	// + 閲覧状態: `none`, `monitoring`, `editing`
	// 最初の`viewstate`コマンドを送る前、または`viewstate:null`,
	// `viewstate:`を送信した後は、このセッションはどこのチャンネルも見ていないことになる。
	// ### `rtcstate`コマンド
	// 自分のWebRTC状態を変更する。
	// 他のコネクションが既に状態を保持している場合、変更することができません。
	// `rtcstate:{チャンネルID}:({状態}:{セッションID})*`
	// コネクションが切断された場合、自分のWebRTC状態はリセットされます。
	// ### `timeline_streaming`コマンド
	// 全てのパブリックチャンネルの`MESSAGE_CREATED`イベントを受け取るかどうかを設定する。
	// 初期状態は`off`です。
	// `timeline_streaming:(on|off|true|false)`
	// ## 受信
	// TextMessageとして各種イベントが`type`と`body`を持つJSONとして非同期に送られます。
	// 例:
	// ```json
	// {"type":"USER_ONLINE","body":{"id":"7dd8e07f-7f5d-4331-9176-b56a4299768b"}}
	// ```
	// ## イベント一覧
	// ### `USER_JOINED`
	// ユーザーが新規登録された。
	// 対象: 全員
	// + `id`: 登録されたユーザーのId
	// ### `USER_UPDATED`
	// ユーザーの情報が更新された。
	// 対象: 全員
	// + `id`: 情報が更新されたユーザーのId
	// ### `USER_TAGS_UPDATED`
	// ユーザーのタグが更新された。
	// 対象: 全員
	// + `id`: タグが更新されたユーザーのId
	// + `tag_id`: 更新されたタグのId
	// ### `USER_ICON_UPDATED`
	// ユーザーのアイコンが更新された。
	// 対象: 全員
	// + `id`: アイコンが更新されたユーザーのId
	// ### `USER_WEBRTC_STATE_CHANGED`
	// ユーザーのWebRTCの状態が変化した
	// 対象: 全員
	// + `user_id`: 変更があったユーザーのId
	// + `channel_id`: ユーザーの変更後の接続チャンネルのId
	// + `sessions`: ユーザーの変更後の状態(配列)
	// + `state`: 状態
	// + `sessionId`: セッションID
	// ### `USER_VIEWSTATE_CHANGED`
	// ユーザーのチャンネルの閲覧状態が変化した
	// 対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て
	// + `view_states`:
	// 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)
	// + `key`: WSセッションの識別子
	// + `channel_id`: 閲覧しているチャンネルId
	// + `state`: 閲覧状態
	// ### `USER_ONLINE`
	// ユーザーがオンラインになった。
	// 対象: 全員
	// + `id`: オンラインになったユーザーのId
	// ### `USER_OFFLINE`
	// ユーザーがオフラインになった。
	// 対象: 全員
	// + `id`: オフラインになったユーザーのId
	// ### `USER_GROUP_CREATED`
	// ユーザーグループが作成された
	// 対象: 全員
	// + `id`: 作成されたユーザーグループのId
	// ### `USER_GROUP_UPDATED`
	// ユーザーグループが更新された
	// 対象: 全員
	// + `id`: 作成されたユーザーグループのId
	// ### `USER_GROUP_DELETED`
	// ユーザーグループが削除された
	// 対象: 全員
	// + `id`: 削除されたユーザーグループのId
	// ### `CHANNEL_CREATED`
	// チャンネルが新規作成された。
	// 対象: 該当チャンネルを閲覧可能な全員
	// + `id`: 作成されたチャンネルのId
	// + `dm_user_id`: (DMの場合のみ) DM相手のユーザーId
	// ### `CHANNEL_UPDATED`
	// チャンネルの情報が変更された。
	// 対象: 該当チャンネルを閲覧可能な全員
	// + `id`: 変更があったチャンネルのId
	// + `dm_user_id`: (DMの場合のみ) DM相手のユーザーId
	// ### `CHANNEL_DELETED`
	// チャンネルが削除された。
	// 対象: 該当チャンネルを閲覧可能な全員
	// + `id`: 削除されたチャンネルのId
	// + `dm_user_id`: (DMの場合のみ) DM相手のユーザーId
	// ### `CHANNEL_STARED`
	// 自分がチャンネルをスターした。
	// 対象: 自分
	// + `id`: スターしたチャンネルのId
	// ### `CHANNEL_UNSTARED`
	// 自分がチャンネルのスターを解除した。
	// 対象: 自分
	// + `id`: スターしたチャンネルのId
	// ### `CHANNEL_VIEWERS_CHANGED`
	// チャンネルの閲覧者が変化した。
	// 対象: 該当チャンネルを閲覧しているユーザー
	// + `id`: 変化したチャンネルのId
	// + `viewers`: 変化後の閲覧者(配列)
	// + `userId`: ユーザーId
	// + `state`: 閲覧状態
	// + `updatedAt`: 閲覧状態の更新日時
	// ### `CHANNEL_SUBSCRIBERS_CHANGED`
	// チャンネルの購読者が変化した。
	// 対象: 該当チャンネルを閲覧しているユーザー
	// + `id`: 変化したチャンネルのId
	// ### `MESSAGE_CREATED`
	// メッセージが投稿された。
	// 対象:
	// 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー
	// + `id`: 投稿されたメッセージのId
	// + `is_citing`:
	// 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか
	// ### `MESSAGE_UPDATED`
	// メッセージが更新された。
	// 対象: 投稿チャンネルを閲覧しているユーザー
	// + `id`: 更新されたメッセージのId
	// ### `MESSAGE_DELETED`
	// メッセージが削除された。
	// 対象: 投稿チャンネルを閲覧しているユーザー
	// + `id`: 削除されたメッセージのId
	// ### `MESSAGE_STAMPED`
	// メッセージにスタンプが押された。
	// 対象: 投稿チャンネルを閲覧しているユーザー
	// + `message_id`: メッセージId
	// + `user_id`: スタンプを押したユーザーのId
	// + `stamp_id`: スタンプのId
	// + `count`: そのユーザーが押した数
	// + `created_at`:
	// そのユーザーがそのスタンプをそのメッセージに最初に押した日時
	// ### `MESSAGE_UNSTAMPED`
	// メッセージからスタンプが外された。
	// 対象: 投稿チャンネルを閲覧しているユーザー
	// + `message_id`: メッセージId
	// + `user_id`: スタンプを押したユーザーのId
	// + `stamp_id`: スタンプのId
	// ### `MESSAGE_PINNED`
	// メッセージがピン留めされた。
	// 対象: 投稿チャンネルを閲覧しているユーザー
	// + `message_id`: ピンされたメッセージのID
	// + `channel_id`: ピンされたメッセージのチャンネルID
	// ### `MESSAGE_UNPINNED`
	// ピン留めされたメッセージのピンが外された。
	// 対象: 投稿チャンネルを閲覧しているユーザー
	// + `message_id`: ピンが外されたメッセージのID
	// + `channel_id`: ピンが外されたメッセージのチャンネルID
	// ### `MESSAGE_READ`
	// 自分があるチャンネルのメッセージを読んだ。
	// 対象: 自分
	// + `id`: 読んだチャンネルId
	// ### `STAMP_CREATED`
	// スタンプが新しく追加された。
	// 対象: 全員
	// + `id`: 作成されたスタンプのId
	// ### `STAMP_UPDATED`
	// スタンプが修正された。
	// 対象: 全員
	// + `id`: 修正されたスタンプのId
	// ### `STAMP_DELETED`
	// スタンプが削除された。
	// 対象: 全員
	// + `id`: 削除されたスタンプのId
	// ### `STAMP_PALETTE_CREATED`
	// スタンプパレットが新しく追加された。
	// 対象: 自分
	// + `id`: 作成されたスタンプパレットのId
	// ### `STAMP_PALETTE_UPDATED`
	// スタンプパレットが修正された。
	// 対象: 自分
	// + `id`: 修正されたスタンプパレットのId
	// ### `STAMP_PALETTE_DELETED`
	// スタンプパレットが削除された。
	// 対象: 自分
	// + `id`: 削除されたスタンプパレットのId
	// ### `CLIP_FOLDER_CREATED`
	// クリップフォルダーが作成された。
	// 対象：自分
	// + `id`: 作成されたクリップフォルダーのId
	// ### `CLIP_FOLDER_UPDATED`
	// クリップフォルダーが修正された。
	// 対象: 自分
	// + `id`: 更新されたクリップフォルダーのId
	// ### `CLIP_FOLDER_DELETED`
	// クリップフォルダーが削除された。
	// 対象: 自分
	// + `id`: 削除されたクリップフォルダーのId
	// ### `CLIP_FOLDER_MESSAGE_DELETED`
	// クリップフォルダーからメッセージが除外された。
	// 対象: 自分
	// + `folder_id`: メッセージが除外されたクリップフォルダーのId
	// + `message_id`: クリップフォルダーから除外されたメッセージのId
	// ### `CLIP_FOLDER_MESSAGE_ADDED`
	// クリップフォルダーにメッセージが追加された。
	// 対象: 自分
	// + `folder_id`: メッセージが追加されたクリップフォルダーのId
	// + `message_id`: クリップフォルダーに追加されたメッセージのId
	// ### `QALL_ROOM_STATE_CHANGED`
	// ルーム状態が変更された。
	// 対象: 全員
	// + `room_id`: 変更されたルームのId
	// + `state`: 変更後のルーム状態
	// + `roomId`: ルームのID
	// + `participants`: ルーム内の参加者(配列)
	// + `identity`: ユーザーID_RandomUUID
	// + `name`: 表示名
	// + `joinedAt`: 参加した時刻
	// + `attributes`: ユーザーに関連付けられたカスタム属性
	// + `canPublish`: 発言権限
	// + `isWebinar`: ウェビナールームかどうか
	// + `metadata`: ルームに関連付けられたカスタム属性
	// ### `QALL_SOUNDBOARD_ITEM_CREATED`
	// サウンドボードアイテムが作成された。
	// 対象: 全員
	// + `sound_id`: 作成されたサウンドのId
	// + `name`: サウンド名
	// + `creator_id`: 作成者のId
	// ### `QALL_SOUNDBOARD_ITEM_DELETED`
	// サウンドボードアイテムが削除された。
	// 対象: 全員
	// + `sound_id`: 削除されたサウンドのId.
	//
	// GET /ws
	Ws(ctx context.Context) error
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// ActivateBot invokes activateBot operation.
//
// 指定したBOTを有効化します。
// 対象のBOTの管理権限が必要です。.
//
// POST /bots/{botId}/actions/activate
func (c *Client) ActivateBot(ctx context.Context, params ActivateBotParams) (ActivateBotRes, error) {
	res, err := c.sendActivateBot(ctx, params)
	return res, err
}

func (c *Client) sendActivateBot(ctx context.Context, params ActivateBotParams) (res ActivateBotRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/activate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ActivateBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ActivateBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeActivateBotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddMessageStamp invokes addMessageStamp operation.
//
// 指定したメッセージに指定したスタンプを押します。.
//
// POST /messages/{messageId}/stamps/{stampId}
func (c *Client) AddMessageStamp(ctx context.Context, request OptPostMessageStampRequest, params AddMessageStampParams) (AddMessageStampRes, error) {
	res, err := c.sendAddMessageStamp(ctx, request, params)
	return res, err
}

func (c *Client) sendAddMessageStamp(ctx context.Context, request OptPostMessageStampRequest, params AddMessageStampParams) (res AddMessageStampRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddMessageStampRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, AddMessageStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, AddMessageStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddMessageStampResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddMyStar invokes addMyStar operation.
//
// 指定したチャンネルをスターチャンネルに追加します。
// スター済みのチャンネルIDを指定した場合、204を返します。
// 不正なチャンネルIDを指定した場合、400を返します。.
//
// POST /users/me/stars
func (c *Client) AddMyStar(ctx context.Context, request OptPostStarRequest) (AddMyStarRes, error) {
	res, err := c.sendAddMyStar(ctx, request)
	return res, err
}

func (c *Client) sendAddMyStar(ctx context.Context, request OptPostStarRequest) (res AddMyStarRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/stars"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddMyStarRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, AddMyStarOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, AddMyStarOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddMyStarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddMyUserTag invokes addMyUserTag operation.
//
// 自分に新しくタグを追加します。.
//
// POST /users/me/tags
func (c *Client) AddMyUserTag(ctx context.Context, request OptPostUserTagRequest) (AddMyUserTagRes, error) {
	res, err := c.sendAddMyUserTag(ctx, request)
	return res, err
}

func (c *Client) sendAddMyUserTag(ctx context.Context, request OptPostUserTagRequest) (res AddMyUserTagRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddMyUserTagRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, AddMyUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, AddMyUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddMyUserTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUserGroupAdmin invokes addUserGroupAdmin operation.
//
// 指定したグループに管理者を追加します。
// 対象のユーザーグループの管理者権限が必要です。.
//
// POST /groups/{groupId}/admins
func (c *Client) AddUserGroupAdmin(ctx context.Context, request OptPostUserGroupAdminRequest, params AddUserGroupAdminParams) (AddUserGroupAdminRes, error) {
	res, err := c.sendAddUserGroupAdmin(ctx, request, params)
	return res, err
}

func (c *Client) sendAddUserGroupAdmin(ctx context.Context, request OptPostUserGroupAdminRequest, params AddUserGroupAdminParams) (res AddUserGroupAdminRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/admins"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUserGroupAdminRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, AddUserGroupAdminOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, AddUserGroupAdminOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddUserGroupAdminResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUserGroupMember invokes addUserGroupMember operation.
//
// 指定したグループにメンバーを追加します。
// 対象のユーザーグループの管理者権限が必要です。.
//
// POST /groups/{groupId}/members
func (c *Client) AddUserGroupMember(ctx context.Context, request OptAddUserGroupMemberReq, params AddUserGroupMemberParams) (AddUserGroupMemberRes, error) {
	res, err := c.sendAddUserGroupMember(ctx, request, params)
	return res, err
}

func (c *Client) sendAddUserGroupMember(ctx context.Context, request OptAddUserGroupMemberReq, params AddUserGroupMemberParams) (res AddUserGroupMemberRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUserGroupMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, AddUserGroupMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, AddUserGroupMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddUserGroupMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddUserTag invokes addUserTag operation.
//
// 指定したユーザーに指定したタグを追加します。
// Webhookユーザーにタグを追加することは出来ません。.
//
// POST /users/{userId}/tags
func (c *Client) AddUserTag(ctx context.Context, request OptPostUserTagRequest, params AddUserTagParams) (AddUserTagRes, error) {
	res, err := c.sendAddUserTag(ctx, request, params)
	return res, err
}

func (c *Client) sendAddUserTag(ctx context.Context, request OptPostUserTagRequest, params AddUserTagParams) (res AddUserTagRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddUserTagRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, AddUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, AddUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddUserTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeMyNotifyCitation invokes changeMyNotifyCitation operation.
//
// メッセージ引用通知の設定情報を変更します.
//
// PUT /users/me/settings/notify-citation
func (c *Client) ChangeMyNotifyCitation(ctx context.Context, request OptPutNotifyCitationRequest) (ChangeMyNotifyCitationRes, error) {
	res, err := c.sendChangeMyNotifyCitation(ctx, request)
	return res, err
}

func (c *Client) sendChangeMyNotifyCitation(ctx context.Context, request OptPutNotifyCitationRequest) (res ChangeMyNotifyCitationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/settings/notify-citation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeMyNotifyCitationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ChangeMyNotifyCitationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ChangeMyNotifyCitationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangeMyNotifyCitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeMyPassword invokes changeMyPassword operation.
//
// 自身のパスワードを変更します。.
//
// PUT /users/me/password
func (c *Client) ChangeMyPassword(ctx context.Context, request OptPutMyPasswordRequest) (ChangeMyPasswordRes, error) {
	res, err := c.sendChangeMyPassword(ctx, request)
	return res, err
}

func (c *Client) sendChangeMyPassword(ctx context.Context, request OptPutMyPasswordRequest) (res ChangeMyPasswordRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/password"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeMyPasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ChangeMyPasswordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ChangeMyPasswordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangeMyPasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeParticipantRole invokes changeParticipantRole operation.
//
// ルーム内の参加者の発言権限を変更します。.
//
// PATCH /qall/rooms/{roomId}/participants
func (c *Client) ChangeParticipantRole(ctx context.Context, request []QallParticipantRequest, params ChangeParticipantRoleParams) (ChangeParticipantRoleRes, error) {
	res, err := c.sendChangeParticipantRole(ctx, request, params)
	return res, err
}

func (c *Client) sendChangeParticipantRole(ctx context.Context, request []QallParticipantRequest, params ChangeParticipantRoleParams) (res ChangeParticipantRoleRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if request == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range request {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/qall/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/participants"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeParticipantRoleRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ChangeParticipantRoleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ChangeParticipantRoleOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangeParticipantRoleResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeStampImage invokes changeStampImage operation.
//
// 指定したスタンプの画像を変更します。.
//
// PUT /stamps/{stampId}/image
func (c *Client) ChangeStampImage(ctx context.Context, request OptChangeStampImageReq, params ChangeStampImageParams) (ChangeStampImageRes, error) {
	res, err := c.sendChangeStampImage(ctx, request, params)
	return res, err
}

func (c *Client) sendChangeStampImage(ctx context.Context, request OptChangeStampImageReq, params ChangeStampImageParams) (res ChangeStampImageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/image"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeStampImageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ChangeStampImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ChangeStampImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangeStampImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeUserPassword invokes changeUserPassword operation.
//
// 指定したユーザーのパスワードを変更します。
// 管理者権限が必要です。.
//
// PUT /users/{userId}/password
func (c *Client) ChangeUserPassword(ctx context.Context, request OptPutUserPasswordRequest, params ChangeUserPasswordParams) (ChangeUserPasswordRes, error) {
	res, err := c.sendChangeUserPassword(ctx, request, params)
	return res, err
}

func (c *Client) sendChangeUserPassword(ctx context.Context, request OptPutUserPasswordRequest, params ChangeUserPasswordParams) (res ChangeUserPasswordRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/password"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeUserPasswordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ChangeUserPasswordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ChangeUserPasswordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangeUserPasswordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ClipMessage invokes clipMessage operation.
//
// 指定したメッセージを指定したクリップフォルダに追加します。.
//
// POST /clip-folders/{folderId}/messages
func (c *Client) ClipMessage(ctx context.Context, request OptPostClipFolderMessageRequest, params ClipMessageParams) (ClipMessageRes, error) {
	res, err := c.sendClipMessage(ctx, request, params)
	return res, err
}

func (c *Client) sendClipMessage(ctx context.Context, request OptPostClipFolderMessageRequest, params ClipMessageParams) (res ClipMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/clip-folders/"
	{
		// Encode "folderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FolderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeClipMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ClipMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ClipMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeClipMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConnectBotWS invokes connectBotWS operation.
//
// # BOT WebSocketプロトコル
// ## 送信
// `コマンド:引数1:引数2:...`
// のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できます。
// ### `rtcstate`コマンド
// 自分のWebRTC状態を変更します。
// 他のコネクションが既に状態を保持している場合、変更することができません。
// `rtcstate:{チャンネルID}:({状態}:{セッションID})*`
// チャンネルIDにnullもしくは空文字を指定するか、状態にnullもしくは空文字を指定した場合、WebRTC状態はリセットされます。
// `rtcstate:null`, `rtcstate:`, `rtcstate:channelId:null`, `rtcstate:channelId:`
// コネクションが切断された場合、自分のWebRTC状態はリセットされます。
// ## 受信
// TextMessageとして各種イベントが`type`、`reqId`、`body`を持つJSONとして非同期に送られます。
// `body`の内容はHTTP Modeの場合のRequest Bodyと同様です。
// 例外として`ERROR`イベントは`reqId`を持ちません。
// 例: PINGイベント
// `{"type":"PING","reqId":"requestId","body":{"eventTime":"2019-05-07T04:50:48.582586882Z"}}`
// ### `ERROR`
// コマンドの引数が不正などの理由でコマンドが受理されなかった場合に送られます。
// 非同期に送られるため、必ずしもコマンドとの対応関係を確定できないことに注意してください。
// 本番環境ではERRORが送られないようにすることが望ましいです。
// `{"type":"ERROR","body":"message"}`.
//
// GET /bots/ws
func (c *Client) ConnectBotWS(ctx context.Context) error {
	_, err := c.sendConnectBotWS(ctx)
	return err
}

func (c *Client) sendConnectBotWS(ctx context.Context) (res *ConnectBotWSSwitchingProtocols, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/bots/ws"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ConnectBotWSOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ConnectBotWSOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeConnectBotWSResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateBot invokes createBot operation.
//
// BOTを作成します。
// 作成後に購読イベントの設定を行う必要があります。
// さらにHTTP Modeの場合はアクティベーションを行う必要があります。.
//
// POST /bots
func (c *Client) CreateBot(ctx context.Context, request OptPostBotRequest) (CreateBotRes, error) {
	res, err := c.sendCreateBot(ctx, request)
	return res, err
}

func (c *Client) sendCreateBot(ctx context.Context, request OptPostBotRequest) (res CreateBotRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/bots"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateBotRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateBotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateChannel invokes createChannel operation.
//
// チャンネルを作成します。
// 階層が6以上になるチャンネルは作成できません。.
//
// POST /channels
func (c *Client) CreateChannel(ctx context.Context, request OptPostChannelRequest) (CreateChannelRes, error) {
	res, err := c.sendCreateChannel(ctx, request)
	return res, err
}

func (c *Client) sendCreateChannel(ctx context.Context, request OptPostChannelRequest) (res CreateChannelRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/channels"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateClient invokes createClient operation.
//
// OAuth2クライアントを作成します。.
//
// POST /clients
func (c *Client) CreateClient(ctx context.Context, request OptPostClientRequest) (CreateClientRes, error) {
	res, err := c.sendCreateClient(ctx, request)
	return res, err
}

func (c *Client) sendCreateClient(ctx context.Context, request OptPostClientRequest) (res CreateClientRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/clients"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateClientRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateClientResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateClipFolder invokes createClipFolder operation.
//
// クリップフォルダを作成します。
// 既にあるフォルダと同名のフォルダを作成することは可能です。.
//
// POST /clip-folders
func (c *Client) CreateClipFolder(ctx context.Context, request OptPostClipFolderRequest) (CreateClipFolderRes, error) {
	res, err := c.sendCreateClipFolder(ctx, request)
	return res, err
}

func (c *Client) sendCreateClipFolder(ctx context.Context, request OptPostClipFolderRequest) (res CreateClipFolderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/clip-folders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateClipFolderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateClipFolderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreatePin invokes createPin operation.
//
// 指定したメッセージをピン留めします。
// アーカイブされているチャンネルのメッセージ・存在しないメッセージ・チャンネル当たりの上限数を超えたメッセージのピン留めはできません。.
//
// POST /messages/{messageId}/pin
func (c *Client) CreatePin(ctx context.Context, params CreatePinParams) (CreatePinRes, error) {
	res, err := c.sendCreatePin(ctx, params)
	return res, err
}

func (c *Client) sendCreatePin(ctx context.Context, params CreatePinParams) (res CreatePinRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreatePinOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreatePinOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreatePinResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateStampPalette invokes createStampPalette operation.
//
// スタンプパレットを作成します。.
//
// POST /stamp-palettes
func (c *Client) CreateStampPalette(ctx context.Context, request OptPostStampPaletteRequest) (CreateStampPaletteRes, error) {
	res, err := c.sendCreateStampPalette(ctx, request)
	return res, err
}

func (c *Client) sendCreateStampPalette(ctx context.Context, request OptPostStampPaletteRequest) (res CreateStampPaletteRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stamp-palettes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateStampPaletteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateStampPaletteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateUser invokes createUser operation.
//
// ユーザーを登録します。
// 管理者権限が必要です。.
//
// POST /users
func (c *Client) CreateUser(ctx context.Context, request OptPostUserRequest) (CreateUserRes, error) {
	res, err := c.sendCreateUser(ctx, request)
	return res, err
}

func (c *Client) sendCreateUser(ctx context.Context, request OptPostUserRequest) (res CreateUserRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateUserGroup invokes createUserGroup operation.
//
// ユーザーグループを作成します。
// 作成者は自動的にグループ管理者になります。.
//
// POST /groups
func (c *Client) CreateUserGroup(ctx context.Context, request OptPostUserGroupRequest) (CreateUserGroupRes, error) {
	res, err := c.sendCreateUserGroup(ctx, request)
	return res, err
}

func (c *Client) sendCreateUserGroup(ctx context.Context, request OptPostUserGroupRequest) (res CreateUserGroupRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateUserGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateUserGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateWebhook invokes createWebhook operation.
//
// Webhookを新規作成します。
// `secret`が空文字の場合、insecureウェブフックが作成されます。.
//
// POST /webhooks
func (c *Client) CreateWebhook(ctx context.Context, request OptPostWebhookRequest) (CreateWebhookRes, error) {
	res, err := c.sendCreateWebhook(ctx, request)
	return res, err
}

func (c *Client) sendCreateWebhook(ctx context.Context, request OptPostWebhookRequest) (res CreateWebhookRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/webhooks"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, CreateWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, CreateWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteBot invokes deleteBot operation.
//
// 指定したBOTを削除します。
// 対象のBOTの管理権限が必要です。.
//
// DELETE /bots/{botId}
func (c *Client) DeleteBot(ctx context.Context, params DeleteBotParams) (DeleteBotRes, error) {
	res, err := c.sendDeleteBot(ctx, params)
	return res, err
}

func (c *Client) sendDeleteBot(ctx context.Context, params DeleteBotParams) (res DeleteBotRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteBotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteClient invokes deleteClient operation.
//
// 指定したOAuth2クライアントを削除します。
// 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。.
//
// DELETE /clients/{clientId}
func (c *Client) DeleteClient(ctx context.Context, params DeleteClientParams) (DeleteClientRes, error) {
	res, err := c.sendDeleteClient(ctx, params)
	return res, err
}

func (c *Client) sendDeleteClient(ctx context.Context, params DeleteClientParams) (res DeleteClientRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clients/"
	{
		// Encode "clientId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clientId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteClientResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteClipFolder invokes deleteClipFolder operation.
//
// 指定したクリップフォルダを削除します。.
//
// DELETE /clip-folders/{folderId}
func (c *Client) DeleteClipFolder(ctx context.Context, params DeleteClipFolderParams) (DeleteClipFolderRes, error) {
	res, err := c.sendDeleteClipFolder(ctx, params)
	return res, err
}

func (c *Client) sendDeleteClipFolder(ctx context.Context, params DeleteClipFolderParams) (res DeleteClipFolderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clip-folders/"
	{
		// Encode "folderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FolderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteClipFolderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteFile invokes deleteFile operation.
//
// 指定したファイルを削除します。
// 指定したファイルの削除権限が必要です。.
//
// DELETE /files/{fileId}
func (c *Client) DeleteFile(ctx context.Context, params DeleteFileParams) (DeleteFileRes, error) {
	res, err := c.sendDeleteFile(ctx, params)
	return res, err
}

func (c *Client) sendDeleteFile(ctx context.Context, params DeleteFileParams) (res DeleteFileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/files/"
	{
		// Encode "fileId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fileId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FileId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteFileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteFileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteMessage invokes deleteMessage operation.
//
// 指定したメッセージを削除します。
// 自身が投稿したメッセージと自身が管理権限を持つWebhookとBOTが投稿したメッセージのみ削除することができます。
// アーカイブされているチャンネルのメッセージを編集することは出来ません。.
//
// DELETE /messages/{messageId}
func (c *Client) DeleteMessage(ctx context.Context, params DeleteMessageParams) (DeleteMessageRes, error) {
	res, err := c.sendDeleteMessage(ctx, params)
	return res, err
}

func (c *Client) sendDeleteMessage(ctx context.Context, params DeleteMessageParams) (res DeleteMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteOgpCache invokes deleteOgpCache operation.
//
// 指定されたURLのOGP情報のキャッシュを削除します。.
//
// DELETE /ogp/cache
func (c *Client) DeleteOgpCache(ctx context.Context, params DeleteOgpCacheParams) (DeleteOgpCacheRes, error) {
	res, err := c.sendDeleteOgpCache(ctx, params)
	return res, err
}

func (c *Client) sendDeleteOgpCache(ctx context.Context, params DeleteOgpCacheParams) (res DeleteOgpCacheRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ogp/cache"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "url" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.URL))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteOgpCacheOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteOgpCacheOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteOgpCacheResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStamp invokes deleteStamp operation.
//
// 指定したスタンプを削除します。
// 対象のスタンプの削除権限が必要です。.
//
// DELETE /stamps/{stampId}
func (c *Client) DeleteStamp(ctx context.Context, params DeleteStampParams) (DeleteStampRes, error) {
	res, err := c.sendDeleteStamp(ctx, params)
	return res, err
}

func (c *Client) sendDeleteStamp(ctx context.Context, params DeleteStampParams) (res DeleteStampRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStampResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteStampPalette invokes deleteStampPalette operation.
//
// 指定したスタンプパレットを削除します。
// 対象のスタンプパレットの管理権限が必要です。.
//
// DELETE /stamp-palettes/{paletteId}
func (c *Client) DeleteStampPalette(ctx context.Context, params DeleteStampPaletteParams) (DeleteStampPaletteRes, error) {
	res, err := c.sendDeleteStampPalette(ctx, params)
	return res, err
}

func (c *Client) sendDeleteStampPalette(ctx context.Context, params DeleteStampPaletteParams) (res DeleteStampPaletteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stamp-palettes/"
	{
		// Encode "paletteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "paletteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PaletteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteStampPaletteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUserGroup invokes deleteUserGroup operation.
//
// 指定したユーザーグループを削除します。
// 対象のユーザーグループの管理者権限が必要です。.
//
// DELETE /groups/{groupId}
func (c *Client) DeleteUserGroup(ctx context.Context, params DeleteUserGroupParams) (DeleteUserGroupRes, error) {
	res, err := c.sendDeleteUserGroup(ctx, params)
	return res, err
}

func (c *Client) sendDeleteUserGroup(ctx context.Context, params DeleteUserGroupParams) (res DeleteUserGroupRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteUserGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWebhook invokes deleteWebhook operation.
//
// 指定したWebhookを削除します。
// Webhookによって投稿されたメッセージは削除されません。.
//
// DELETE /webhooks/{webhookId}
func (c *Client) DeleteWebhook(ctx context.Context, params DeleteWebhookParams) (DeleteWebhookRes, error) {
	res, err := c.sendDeleteWebhook(ctx, params)
	return res, err
}

func (c *Client) sendDeleteWebhook(ctx context.Context, params DeleteWebhookParams) (res DeleteWebhookRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/webhooks/"
	{
		// Encode "webhookId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhookId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WebhookId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteWebhookMessage invokes DeleteWebhookMessage operation.
//
// Webhookの投稿メッセージを削除.
//
// DELETE /webhooks/:webhookID/messages/:messageID
func (c *Client) DeleteWebhookMessage(ctx context.Context, params DeleteWebhookMessageParams) (DeleteWebhookMessageRes, error) {
	res, err := c.sendDeleteWebhookMessage(ctx, params)
	return res, err
}

func (c *Client) sendDeleteWebhookMessage(ctx context.Context, params DeleteWebhookMessageParams) (res DeleteWebhookMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/webhooks/:webhookID/messages/:messageID"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, DeleteWebhookMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, DeleteWebhookMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteWebhookMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditBot invokes editBot operation.
//
// 指定したBOTの情報を変更します。
// 対象のBOTの管理権限が必要です。
// BOT開発者UUIDを変更した場合は、変更先ユーザーにBOT管理権限が移譲され、自分自身は権限を失います。.
//
// PATCH /bots/{botId}
func (c *Client) EditBot(ctx context.Context, request OptPatchBotRequest, params EditBotParams) (EditBotRes, error) {
	res, err := c.sendEditBot(ctx, request, params)
	return res, err
}

func (c *Client) sendEditBot(ctx context.Context, request OptPatchBotRequest, params EditBotParams) (res EditBotRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditBotRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditBotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditChannel invokes editChannel operation.
//
// 指定したチャンネルの情報を変更します。
// 変更には権限が必要です。
// ルートチャンネルに移動させる場合は、`parent`に`00000000-0000-0000-0000-000000000000`を指定してください。.
//
// PATCH /channels/{channelId}
func (c *Client) EditChannel(ctx context.Context, request OptPatchChannelRequest, params EditChannelParams) (EditChannelRes, error) {
	res, err := c.sendEditChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendEditChannel(ctx context.Context, request OptPatchChannelRequest, params EditChannelParams) (res EditChannelRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditChannelSubscribers invokes editChannelSubscribers operation.
//
// 指定したチャンネルの通知購読者を編集します。
// リクエストに含めなかったユーザーの通知購読状態は変更しません。
// また、存在しないユーザーを指定した場合は無視されます。.
//
// PATCH /channels/{channelId}/subscribers
func (c *Client) EditChannelSubscribers(ctx context.Context, request OptPatchChannelSubscribersRequest, params EditChannelSubscribersParams) (EditChannelSubscribersRes, error) {
	res, err := c.sendEditChannelSubscribers(ctx, request, params)
	return res, err
}

func (c *Client) sendEditChannelSubscribers(ctx context.Context, request OptPatchChannelSubscribersRequest, params EditChannelSubscribersParams) (res EditChannelSubscribersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscribers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditChannelSubscribersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditChannelSubscribersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditChannelSubscribersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditChannelSubscribersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditChannelTopic invokes editChannelTopic operation.
//
// 指定したチャンネルのトピックを編集します。
// アーカイブされているチャンネルのトピックは編集できません。.
//
// PUT /channels/{channelId}/topic
func (c *Client) EditChannelTopic(ctx context.Context, request OptPutChannelTopicRequest, params EditChannelTopicParams) (EditChannelTopicRes, error) {
	res, err := c.sendEditChannelTopic(ctx, request, params)
	return res, err
}

func (c *Client) sendEditChannelTopic(ctx context.Context, request OptPutChannelTopicRequest, params EditChannelTopicParams) (res EditChannelTopicRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/topic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditChannelTopicRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditChannelTopicOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditChannelTopicOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditChannelTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditClient invokes editClient operation.
//
// 指定したOAuth2クライアントの情報を変更します。
// 対象のクライアントの管理権限が必要です。
// クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。.
//
// PATCH /clients/{clientId}
func (c *Client) EditClient(ctx context.Context, request OptPatchClientRequest, params EditClientParams) (EditClientRes, error) {
	res, err := c.sendEditClient(ctx, request, params)
	return res, err
}

func (c *Client) sendEditClient(ctx context.Context, request OptPatchClientRequest, params EditClientParams) (res EditClientRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clients/"
	{
		// Encode "clientId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clientId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditClientRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditClientResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditClipFolder invokes editClipFolder operation.
//
// 指定したクリップフォルダの情報を編集します。.
//
// PATCH /clip-folders/{folderId}
func (c *Client) EditClipFolder(ctx context.Context, request OptPatchClipFolderRequest, params EditClipFolderParams) (EditClipFolderRes, error) {
	res, err := c.sendEditClipFolder(ctx, request, params)
	return res, err
}

func (c *Client) sendEditClipFolder(ctx context.Context, request OptPatchClipFolderRequest, params EditClipFolderParams) (res EditClipFolderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clip-folders/"
	{
		// Encode "folderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FolderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditClipFolderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditClipFolderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMe invokes editMe operation.
//
// 自身のユーザー情報を変更します。.
//
// PATCH /users/me
func (c *Client) EditMe(ctx context.Context, request OptPatchMeRequest) (EditMeRes, error) {
	res, err := c.sendEditMe(ctx, request)
	return res, err
}

func (c *Client) sendEditMe(ctx context.Context, request OptPatchMeRequest) (res EditMeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditMeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditMeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMessage invokes editMessage operation.
//
// 指定したメッセージを編集します。
// 自身が投稿したメッセージのみ編集することができます。
// アーカイブされているチャンネルのメッセージを編集することは出来ません。.
//
// PUT /messages/{messageId}
func (c *Client) EditMessage(ctx context.Context, request OptPostMessageRequest, params EditMessageParams) (EditMessageRes, error) {
	res, err := c.sendEditMessage(ctx, request, params)
	return res, err
}

func (c *Client) sendEditMessage(ctx context.Context, request OptPostMessageRequest, params EditMessageParams) (res EditMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditMyUserTag invokes editMyUserTag operation.
//
// 自分の指定したタグの状態を変更します。.
//
// PATCH /users/me/tags/{tagId}
func (c *Client) EditMyUserTag(ctx context.Context, request OptPatchUserTagRequest, params EditMyUserTagParams) (EditMyUserTagRes, error) {
	res, err := c.sendEditMyUserTag(ctx, request, params)
	return res, err
}

func (c *Client) sendEditMyUserTag(ctx context.Context, request OptPatchUserTagRequest, params EditMyUserTagParams) (res EditMyUserTagRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/me/tags/"
	{
		// Encode "tagId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tagId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TagId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditMyUserTagRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditMyUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditMyUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditMyUserTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditStamp invokes editStamp operation.
//
// 指定したスタンプの情報を変更します。.
//
// PATCH /stamps/{stampId}
func (c *Client) EditStamp(ctx context.Context, request OptPatchStampRequest, params EditStampParams) (EditStampRes, error) {
	res, err := c.sendEditStamp(ctx, request, params)
	return res, err
}

func (c *Client) sendEditStamp(ctx context.Context, request OptPatchStampRequest, params EditStampParams) (res EditStampRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditStampRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditStampResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditStampPalette invokes editStampPalette operation.
//
// 指定したスタンプパレットを編集します。
// リクエストのスタンプの配列の順番は保存されて変更されます。
// 対象のスタンプパレットの管理権限が必要です。.
//
// PATCH /stamp-palettes/{paletteId}
func (c *Client) EditStampPalette(ctx context.Context, request OptPatchStampPaletteRequest, params EditStampPaletteParams) (EditStampPaletteRes, error) {
	res, err := c.sendEditStampPalette(ctx, request, params)
	return res, err
}

func (c *Client) sendEditStampPalette(ctx context.Context, request OptPatchStampPaletteRequest, params EditStampPaletteParams) (res EditStampPaletteRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stamp-palettes/"
	{
		// Encode "paletteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "paletteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PaletteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditStampPaletteRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditStampPaletteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditUser invokes editUser operation.
//
// 指定したユーザーの情報を変更します。
// 管理者権限が必要です。.
//
// PATCH /users/{userId}
func (c *Client) EditUser(ctx context.Context, request OptPatchUserRequest, params EditUserParams) (EditUserRes, error) {
	res, err := c.sendEditUser(ctx, request, params)
	return res, err
}

func (c *Client) sendEditUser(ctx context.Context, request OptPatchUserRequest, params EditUserParams) (res EditUserRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditUserGroup invokes editUserGroup operation.
//
// 指定したユーザーグループの情報を編集します。
// 対象のユーザーグループの管理者権限が必要です。.
//
// PATCH /groups/{groupId}
func (c *Client) EditUserGroup(ctx context.Context, request OptPatchUserGroupRequest, params EditUserGroupParams) (EditUserGroupRes, error) {
	res, err := c.sendEditUserGroup(ctx, request, params)
	return res, err
}

func (c *Client) sendEditUserGroup(ctx context.Context, request OptPatchUserGroupRequest, params EditUserGroupParams) (res EditUserGroupRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditUserGroupRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditUserGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditUserGroupMember invokes editUserGroupMember operation.
//
// 指定したユーザーグループ内の指定したユーザーの属性を編集します。
// 対象のユーザーグループの管理者権限が必要です。.
//
// PATCH /groups/{groupId}/members/{userId}
func (c *Client) EditUserGroupMember(ctx context.Context, request OptPatchGroupMemberRequest, params EditUserGroupMemberParams) (EditUserGroupMemberRes, error) {
	res, err := c.sendEditUserGroupMember(ctx, request, params)
	return res, err
}

func (c *Client) sendEditUserGroupMember(ctx context.Context, request OptPatchGroupMemberRequest, params EditUserGroupMemberParams) (res EditUserGroupMemberRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditUserGroupMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditUserGroupMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditUserGroupMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditUserGroupMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditUserTag invokes editUserTag operation.
//
// 指定したユーザーの指定したタグの状態を変更します。
// 他人の状態は変更できません。.
//
// PATCH /users/{userId}/tags/{tagId}
func (c *Client) EditUserTag(ctx context.Context, request OptPatchUserTagRequest, params EditUserTagParams) (EditUserTagRes, error) {
	res, err := c.sendEditUserTag(ctx, request, params)
	return res, err
}

func (c *Client) sendEditUserTag(ctx context.Context, request OptPatchUserTagRequest, params EditUserTagParams) (res EditUserTagRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/"
	{
		// Encode "tagId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tagId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TagId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditUserTagRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditUserTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EditWebhook invokes editWebhook operation.
//
// 指定したWebhookの情報を変更します。.
//
// PATCH /webhooks/{webhookId}
func (c *Client) EditWebhook(ctx context.Context, request OptPatchWebhookRequest, params EditWebhookParams) (EditWebhookRes, error) {
	res, err := c.sendEditWebhook(ctx, request, params)
	return res, err
}

func (c *Client) sendEditWebhook(ctx context.Context, request OptPatchWebhookRequest, params EditWebhookParams) (res EditWebhookRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/webhooks/"
	{
		// Encode "webhookId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhookId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WebhookId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEditWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, EditWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, EditWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEditWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetActivityTimeline invokes getActivityTimeline operation.
//
// パブリックチャンネルの直近の投稿メッセージを作成日時の降順で取得します。
// `all`が`true`でない場合、購読チャンネルのみのタイムラインを取得します.
//
// GET /activity/timeline
func (c *Client) GetActivityTimeline(ctx context.Context, params GetActivityTimelineParams) (GetActivityTimelineRes, error) {
	res, err := c.sendGetActivityTimeline(ctx, params)
	return res, err
}

func (c *Client) sendGetActivityTimeline(ctx context.Context, params GetActivityTimelineParams) (res GetActivityTimelineRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/activity/timeline"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "all" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "per_channel" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "per_channel",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PerChannel.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetActivityTimelineOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetActivityTimelineOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetActivityTimelineResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBot invokes getBot operation.
//
// 指定したBOTのBOT情報を取得します。
// BOT詳細情報を取得する場合は、対象のBOTの管理権限が必要です。.
//
// GET /bots/{botId}
func (c *Client) GetBot(ctx context.Context, params GetBotParams) (GetBotRes, error) {
	res, err := c.sendGetBot(ctx, params)
	return res, err
}

func (c *Client) sendGetBot(ctx context.Context, params GetBotParams) (res GetBotRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "detail" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detail",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Detail.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBotIcon invokes getBotIcon operation.
//
// 指定したBOTのアイコン画像を取得を取得します。.
//
// GET /bots/{botId}/icon
func (c *Client) GetBotIcon(ctx context.Context, params GetBotIconParams) (GetBotIconRes, error) {
	res, err := c.sendGetBotIcon(ctx, params)
	return res, err
}

func (c *Client) sendGetBotIcon(ctx context.Context, params GetBotIconParams) (res GetBotIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/icon"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetBotIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetBotIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBotIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBotLogs invokes getBotLogs operation.
//
// 指定したBOTのイベントログを取得します。
// 対象のBOTの管理権限が必要です。.
//
// GET /bots/{botId}/logs
func (c *Client) GetBotLogs(ctx context.Context, params GetBotLogsParams) (GetBotLogsRes, error) {
	res, err := c.sendGetBotLogs(ctx, params)
	return res, err
}

func (c *Client) sendGetBotLogs(ctx context.Context, params GetBotLogsParams) (res GetBotLogsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/logs"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetBotLogsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetBotLogsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBotLogsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetBots invokes getBots operation.
//
// BOT情報のリストを取得します。
// allを指定しない場合、自分が開発者のBOTのみを返します。.
//
// GET /bots
func (c *Client) GetBots(ctx context.Context, params GetBotsParams) ([]Bot, error) {
	res, err := c.sendGetBots(ctx, params)
	return res, err
}

func (c *Client) sendGetBots(ctx context.Context, params GetBotsParams) (res []Bot, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/bots"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "all" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetBotsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetBotsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetBotsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannel invokes getChannel operation.
//
// 指定したチャンネルの情報を取得します。.
//
// GET /channels/{channelId}
func (c *Client) GetChannel(ctx context.Context, params GetChannelParams) (GetChannelRes, error) {
	res, err := c.sendGetChannel(ctx, params)
	return res, err
}

func (c *Client) sendGetChannel(ctx context.Context, params GetChannelParams) (res GetChannelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannelBots invokes getChannelBots operation.
//
// 指定したチャンネルに参加しているBOTのリストを取得します。.
//
// GET /channels/{channelId}/bots
func (c *Client) GetChannelBots(ctx context.Context, params GetChannelBotsParams) (GetChannelBotsRes, error) {
	res, err := c.sendGetChannelBots(ctx, params)
	return res, err
}

func (c *Client) sendGetChannelBots(ctx context.Context, params GetChannelBotsParams) (res GetChannelBotsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bots"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelBotsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelBotsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelBotsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannelPath invokes getChannelPath operation.
//
// 指定したチャンネルパスを取得.
//
// GET /channels/{channelId}/path
func (c *Client) GetChannelPath(ctx context.Context, params GetChannelPathParams) (GetChannelPathRes, error) {
	res, err := c.sendGetChannelPath(ctx, params)
	return res, err
}

func (c *Client) sendGetChannelPath(ctx context.Context, params GetChannelPathParams) (res GetChannelPathRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/path"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelPathOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelPathOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelPathResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannelPins invokes getChannelPins operation.
//
// 指定したチャンネルにピン留めされているピンメッセージのリストを取得します。.
//
// GET /channels/{channelId}/pins
func (c *Client) GetChannelPins(ctx context.Context, params GetChannelPinsParams) (GetChannelPinsRes, error) {
	res, err := c.sendGetChannelPins(ctx, params)
	return res, err
}

func (c *Client) sendGetChannelPins(ctx context.Context, params GetChannelPinsParams) (res GetChannelPinsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pins"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelPinsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelPinsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelPinsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannelStats invokes getChannelStats operation.
//
// 指定したチャンネルの統計情報を取得します。.
//
// GET /channels/{channelId}/stats
func (c *Client) GetChannelStats(ctx context.Context, params GetChannelStatsParams) (GetChannelStatsRes, error) {
	res, err := c.sendGetChannelStats(ctx, params)
	return res, err
}

func (c *Client) sendGetChannelStats(ctx context.Context, params GetChannelStatsParams) (res GetChannelStatsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stats"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "exclude-deleted-messages" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "exclude-deleted-messages",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ExcludeDeletedMessages.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannelSubscribers invokes getChannelSubscribers operation.
//
// 指定したチャンネルを通知購読しているユーザーのUUIDのリストを取得します。.
//
// GET /channels/{channelId}/subscribers
func (c *Client) GetChannelSubscribers(ctx context.Context, params GetChannelSubscribersParams) (GetChannelSubscribersRes, error) {
	res, err := c.sendGetChannelSubscribers(ctx, params)
	return res, err
}

func (c *Client) sendGetChannelSubscribers(ctx context.Context, params GetChannelSubscribersParams) (res GetChannelSubscribersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscribers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelSubscribersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelSubscribersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelSubscribersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannelTopic invokes getChannelTopic operation.
//
// 指定したチャンネルのトピックを取得します。.
//
// GET /channels/{channelId}/topic
func (c *Client) GetChannelTopic(ctx context.Context, params GetChannelTopicParams) (GetChannelTopicRes, error) {
	res, err := c.sendGetChannelTopic(ctx, params)
	return res, err
}

func (c *Client) sendGetChannelTopic(ctx context.Context, params GetChannelTopicParams) (res GetChannelTopicRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/topic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelTopicOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelTopicOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelTopicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannelViewers invokes getChannelViewers operation.
//
// 指定したチャンネルの閲覧者のリストを取得します。.
//
// GET /channels/{channelId}/viewers
func (c *Client) GetChannelViewers(ctx context.Context, params GetChannelViewersParams) (GetChannelViewersRes, error) {
	res, err := c.sendGetChannelViewers(ctx, params)
	return res, err
}

func (c *Client) sendGetChannelViewers(ctx context.Context, params GetChannelViewersParams) (res GetChannelViewersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/viewers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelViewersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelViewersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelViewersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetChannels invokes getChannels operation.
//
// チャンネルのリストを取得します。.
//
// GET /channels
func (c *Client) GetChannels(ctx context.Context, params GetChannelsParams) (*ChannelList, error) {
	res, err := c.sendGetChannels(ctx, params)
	return res, err
}

func (c *Client) sendGetChannels(ctx context.Context, params GetChannelsParams) (res *ChannelList, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/channels"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include-dm" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include-dm",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeDm.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "path" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "path",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Path.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetChannelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetChannelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClient invokes getClient operation.
//
// 指定したOAuth2クライアントの情報を取得します。
// 詳細情報の取得には対象のクライアントの管理権限が必要です。.
//
// GET /clients/{clientId}
func (c *Client) GetClient(ctx context.Context, params GetClientParams) (GetClientRes, error) {
	res, err := c.sendGetClient(ctx, params)
	return res, err
}

func (c *Client) sendGetClient(ctx context.Context, params GetClientParams) (res GetClientRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clients/"
	{
		// Encode "clientId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clientId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "detail" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "detail",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Detail.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetClientOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClientResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClients invokes getClients operation.
//
// 自身が開発者のOAuth2クライアントのリストを取得します。
// `all`が`true`の場合、全開発者の全クライアントのリストを返します。.
//
// GET /clients
func (c *Client) GetClients(ctx context.Context, params GetClientsParams) ([]OAuth2Client, error) {
	res, err := c.sendGetClients(ctx, params)
	return res, err
}

func (c *Client) sendGetClients(ctx context.Context, params GetClientsParams) (res []OAuth2Client, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/clients"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "all" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetClientsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetClientsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClientsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClipFolder invokes getClipFolder operation.
//
// 指定したクリップフォルダの情報を取得します。.
//
// GET /clip-folders/{folderId}
func (c *Client) GetClipFolder(ctx context.Context, params GetClipFolderParams) (GetClipFolderRes, error) {
	res, err := c.sendGetClipFolder(ctx, params)
	return res, err
}

func (c *Client) sendGetClipFolder(ctx context.Context, params GetClipFolderParams) (res GetClipFolderRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/clip-folders/"
	{
		// Encode "folderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FolderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetClipFolderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClipFolderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClipFolders invokes getClipFolders operation.
//
// 自身が所有するクリップフォルダのリストを取得します。.
//
// GET /clip-folders
func (c *Client) GetClipFolders(ctx context.Context) ([]ClipFolder, error) {
	res, err := c.sendGetClipFolders(ctx)
	return res, err
}

func (c *Client) sendGetClipFolders(ctx context.Context) (res []ClipFolder, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/clip-folders"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetClipFoldersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetClipFoldersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClipFoldersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetClips invokes getClips operation.
//
// 指定したフォルダ内のクリップのリストを取得します。
// `order`を指定しない場合、クリップした日時の新しい順で返されます。.
//
// GET /clip-folders/{folderId}/messages
func (c *Client) GetClips(ctx context.Context, params GetClipsParams) (GetClipsRes, error) {
	res, err := c.sendGetClips(ctx, params)
	return res, err
}

func (c *Client) sendGetClips(ctx context.Context, params GetClipsParams) (res GetClipsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/clip-folders/"
	{
		// Encode "folderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FolderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetClipsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetClipsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetClipsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDirectMessages invokes getDirectMessages operation.
//
// 指定したユーザーとのダイレクトメッセージのリストを取得します。.
//
// GET /users/{userId}/messages
func (c *Client) GetDirectMessages(ctx context.Context, params GetDirectMessagesParams) (GetDirectMessagesRes, error) {
	res, err := c.sendGetDirectMessages(ctx, params)
	return res, err
}

func (c *Client) sendGetDirectMessages(ctx context.Context, params GetDirectMessagesParams) (res GetDirectMessagesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "until" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "inclusive" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "inclusive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Inclusive.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetDirectMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetDirectMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDirectMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFile invokes getFile operation.
//
// 指定したファイル本体を取得します。
// 指定したファイルへのアクセス権限が必要です。.
//
// GET /files/{fileId}
func (c *Client) GetFile(ctx context.Context, params GetFileParams) (GetFileRes, error) {
	res, err := c.sendGetFile(ctx, params)
	return res, err
}

func (c *Client) sendGetFile(ctx context.Context, params GetFileParams) (res GetFileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/files/"
	{
		// Encode "fileId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fileId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FileId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "dl" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "dl",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Dl.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetFileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetFileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFileMeta invokes getFileMeta operation.
//
// 指定したファイルのメタ情報を取得します。
// 指定したファイルへのアクセス権限が必要です。.
//
// GET /files/{fileId}/meta
func (c *Client) GetFileMeta(ctx context.Context, params GetFileMetaParams) (GetFileMetaRes, error) {
	res, err := c.sendGetFileMeta(ctx, params)
	return res, err
}

func (c *Client) sendGetFileMeta(ctx context.Context, params GetFileMetaParams) (res GetFileMetaRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/files/"
	{
		// Encode "fileId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fileId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FileId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/meta"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetFileMetaOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetFileMetaOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFileMetaResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFiles invokes getFiles operation.
//
// 指定したクエリでファイルメタのリストを取得します。
// クエリパラメータ`channelId`, `mine`の少なくともいずれかが必須です。.
//
// GET /files
func (c *Client) GetFiles(ctx context.Context, params GetFilesParams) (GetFilesRes, error) {
	res, err := c.sendGetFiles(ctx, params)
	return res, err
}

func (c *Client) sendGetFiles(ctx context.Context, params GetFilesParams) (res GetFilesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "channelId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "channelId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ChannelId.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "until" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "inclusive" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "inclusive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Inclusive.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "mine" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "mine",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Mine.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetFilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetFilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLiveKitToken invokes getLiveKitToken operation.
//
// 指定したルームに参加するためのLiveKitトークンを取得します。.
//
// GET /qall/token
func (c *Client) GetLiveKitToken(ctx context.Context, params GetLiveKitTokenParams) (GetLiveKitTokenRes, error) {
	res, err := c.sendGetLiveKitToken(ctx, params)
	return res, err
}

func (c *Client) sendGetLiveKitToken(ctx context.Context, params GetLiveKitTokenParams) (res GetLiveKitTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/qall/token"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "roomId" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "roomId",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RoomId.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "isWebinar" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "isWebinar",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsWebinar.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetLiveKitTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetLiveKitTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLiveKitTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMe invokes getMe operation.
//
// 自身のユーザー詳細情報を取得します。.
//
// GET /users/me
func (c *Client) GetMe(ctx context.Context) (*MyUserDetail, error) {
	res, err := c.sendGetMe(ctx)
	return res, err
}

func (c *Client) sendGetMe(ctx context.Context) (res *MyUserDetail, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMessage invokes getMessage operation.
//
// 指定したメッセージを取得します。.
//
// GET /messages/{messageId}
func (c *Client) GetMessage(ctx context.Context, params GetMessageParams) (GetMessageRes, error) {
	res, err := c.sendGetMessage(ctx, params)
	return res, err
}

func (c *Client) sendGetMessage(ctx context.Context, params GetMessageParams) (res GetMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMessageClips invokes getMessageClips operation.
//
// 対象のメッセージの自分のクリップの一覧を返します。.
//
// GET /messages/{messageId}/clips
func (c *Client) GetMessageClips(ctx context.Context, params GetMessageClipsParams) (GetMessageClipsRes, error) {
	res, err := c.sendGetMessageClips(ctx, params)
	return res, err
}

func (c *Client) sendGetMessageClips(ctx context.Context, params GetMessageClipsParams) (res GetMessageClipsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/clips"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMessageClipsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMessageClipsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMessageClipsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMessageStamps invokes getMessageStamps operation.
//
// 指定したメッセージに押されているスタンプのリストを取得します。.
//
// GET /messages/{messageId}/stamps
func (c *Client) GetMessageStamps(ctx context.Context, params GetMessageStampsParams) (GetMessageStampsRes, error) {
	res, err := c.sendGetMessageStamps(ctx, params)
	return res, err
}

func (c *Client) sendGetMessageStamps(ctx context.Context, params GetMessageStampsParams) (res GetMessageStampsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stamps"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMessageStampsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMessageStampsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMessageStampsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMessages invokes getMessages operation.
//
// 指定したチャンネルのメッセージのリストを取得します。.
//
// GET /channels/{channelId}/messages
func (c *Client) GetMessages(ctx context.Context, params GetMessagesParams) (GetMessagesRes, error) {
	res, err := c.sendGetMessages(ctx, params)
	return res, err
}

func (c *Client) sendGetMessages(ctx context.Context, params GetMessagesParams) (res GetMessagesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "until" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "inclusive" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "inclusive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Inclusive.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyChannelSubscriptions invokes getMyChannelSubscriptions operation.
//
// 自身のチャンネル購読状態を取得します。.
//
// GET /users/me/subscriptions
func (c *Client) GetMyChannelSubscriptions(ctx context.Context) ([]UserSubscribeState, error) {
	res, err := c.sendGetMyChannelSubscriptions(ctx)
	return res, err
}

func (c *Client) sendGetMyChannelSubscriptions(ctx context.Context) (res []UserSubscribeState, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyChannelSubscriptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyChannelSubscriptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyChannelSubscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyExternalAccounts invokes getMyExternalAccounts operation.
//
// 自分に紐付けられている外部ログインアカウント一覧を取得します。.
//
// GET /users/me/ex-accounts
func (c *Client) GetMyExternalAccounts(ctx context.Context) ([]ExternalProviderUser, error) {
	res, err := c.sendGetMyExternalAccounts(ctx)
	return res, err
}

func (c *Client) sendGetMyExternalAccounts(ctx context.Context) (res []ExternalProviderUser, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/ex-accounts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyExternalAccountsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyExternalAccountsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyExternalAccountsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyIcon invokes getMyIcon operation.
//
// 自分のアイコン画像を取得します。.
//
// GET /users/me/icon
func (c *Client) GetMyIcon(ctx context.Context) (GetMyIconRes, error) {
	res, err := c.sendGetMyIcon(ctx)
	return res, err
}

func (c *Client) sendGetMyIcon(ctx context.Context) (res GetMyIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/icon"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyNotifyCitation invokes getMyNotifyCitation operation.
//
// メッセージ引用通知の設定情報を変更します。.
//
// GET /users/me/settings/notify-citation
func (c *Client) GetMyNotifyCitation(ctx context.Context) (*GetNotifyCitation, error) {
	res, err := c.sendGetMyNotifyCitation(ctx)
	return res, err
}

func (c *Client) sendGetMyNotifyCitation(ctx context.Context) (res *GetNotifyCitation, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/settings/notify-citation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyNotifyCitationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyNotifyCitationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyNotifyCitationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyQRCode invokes getMyQRCode operation.
//
// 自身のQRコードを取得します。
// 返されたQRコードまたはトークンは、発行後の5分間のみ有効です.
//
// GET /users/me/qr-code
func (c *Client) GetMyQRCode(ctx context.Context, params GetMyQRCodeParams) (GetMyQRCodeRes, error) {
	res, err := c.sendGetMyQRCode(ctx, params)
	return res, err
}

func (c *Client) sendGetMyQRCode(ctx context.Context, params GetMyQRCodeParams) (res GetMyQRCodeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/qr-code"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "token" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "token",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Token.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyQRCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyQRCodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyQRCodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMySessions invokes getMySessions operation.
//
// 自分のログインセッションのリストを取得します。.
//
// GET /users/me/sessions
func (c *Client) GetMySessions(ctx context.Context) ([]LoginSession, error) {
	res, err := c.sendGetMySessions(ctx)
	return res, err
}

func (c *Client) sendGetMySessions(ctx context.Context) (res []LoginSession, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/sessions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMySessionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMySessionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMySessionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyStampHistory invokes getMyStampHistory operation.
//
// 自分のスタンプ履歴を最大100件まで取得します。
// 結果は降順で返されます。
// このAPIが返すスタンプ履歴は厳密な履歴ではありません。.
//
// GET /users/me/stamp-history
func (c *Client) GetMyStampHistory(ctx context.Context, params GetMyStampHistoryParams) ([]StampHistoryEntry, error) {
	res, err := c.sendGetMyStampHistory(ctx, params)
	return res, err
}

func (c *Client) sendGetMyStampHistory(ctx context.Context, params GetMyStampHistoryParams) (res []StampHistoryEntry, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/stamp-history"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyStampHistoryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyStampHistoryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyStampHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyStars invokes getMyStars operation.
//
// 自分がスターしているチャンネルのUUIDの配列を取得します。.
//
// GET /users/me/stars
func (c *Client) GetMyStars(ctx context.Context) ([]uuid.UUID, error) {
	res, err := c.sendGetMyStars(ctx)
	return res, err
}

func (c *Client) sendGetMyStars(ctx context.Context) (res []uuid.UUID, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/stars"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyStarsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyStarsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyStarsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyTokens invokes getMyTokens operation.
//
// 有効な自分に発行されたOAuth2トークンのリストを取得します。.
//
// GET /users/me/tokens
func (c *Client) GetMyTokens(ctx context.Context) ([]ActiveOAuth2Token, error) {
	res, err := c.sendGetMyTokens(ctx)
	return res, err
}

func (c *Client) sendGetMyTokens(ctx context.Context) (res []ActiveOAuth2Token, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyUnreadChannels invokes getMyUnreadChannels operation.
//
// 自分が現在未読のチャンネルの未読情報を取得します。.
//
// GET /users/me/unread
func (c *Client) GetMyUnreadChannels(ctx context.Context) ([]UnreadChannel, error) {
	res, err := c.sendGetMyUnreadChannels(ctx)
	return res, err
}

func (c *Client) sendGetMyUnreadChannels(ctx context.Context) (res []UnreadChannel, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/unread"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyUnreadChannelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyUnreadChannelsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyUnreadChannelsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyUserTags invokes getMyUserTags operation.
//
// 自分に付けられているタグの配列を取得します。.
//
// GET /users/me/tags
func (c *Client) GetMyUserTags(ctx context.Context) ([]UserTag, error) {
	res, err := c.sendGetMyUserTags(ctx)
	return res, err
}

func (c *Client) sendGetMyUserTags(ctx context.Context) (res []UserTag, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyUserTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyUserTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyUserTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetMyViewStates invokes getMyViewStates operation.
//
// 自身のチャンネル閲覧状態一覧を取得します。.
//
// GET /users/me/view-states
func (c *Client) GetMyViewStates(ctx context.Context) ([]MyChannelViewState, error) {
	res, err := c.sendGetMyViewStates(ctx)
	return res, err
}

func (c *Client) sendGetMyViewStates(ctx context.Context) (res []MyChannelViewState, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/view-states"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetMyViewStatesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetMyViewStatesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetMyViewStatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOAuth2Authorize invokes getOAuth2Authorize operation.
//
// OAuth2 認可エンドポイント.
//
// GET /oauth2/authorize
func (c *Client) GetOAuth2Authorize(ctx context.Context, params GetOAuth2AuthorizeParams) (GetOAuth2AuthorizeRes, error) {
	res, err := c.sendGetOAuth2Authorize(ctx, params)
	return res, err
}

func (c *Client) sendGetOAuth2Authorize(ctx context.Context, params GetOAuth2AuthorizeParams) (res GetOAuth2AuthorizeRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/oauth2/authorize"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "response_type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "response_type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.ResponseType.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "client_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "client_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.ClientID))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "redirect_uri" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redirect_uri",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.RedirectURI.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "scope" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "scope",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Scope.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "state" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "state",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.State.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "code_challenge" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code_challenge",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CodeChallenge.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "code_challenge_method" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "code_challenge_method",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.CodeChallengeMethod.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "nonce" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "nonce",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Nonce.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "prompt" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "prompt",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Prompt.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetOAuth2AuthorizeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetOAuth2AuthorizeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOAuth2AuthorizeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOIDCUserInfo invokes getOIDCUserInfo operation.
//
// OIDCトークンを用いてユーザー詳細を取得します。
// OIDC UserInfo Endpointです。.
//
// GET /users/me/oidc
func (c *Client) GetOIDCUserInfo(ctx context.Context) (*OIDCUserInfo, error) {
	res, err := c.sendGetOIDCUserInfo(ctx)
	return res, err
}

func (c *Client) sendGetOIDCUserInfo(ctx context.Context) (res *OIDCUserInfo, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/oidc"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetOIDCUserInfoOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetOIDCUserInfoOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOIDCUserInfoResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOgp invokes getOgp operation.
//
// 指定されたURLのOGP情報を取得します。
// 指定されたURLに対するOGP情報が見つからなかった場合、typeがemptyに設定された空のOGP情報を返します。.
//
// GET /ogp
func (c *Client) GetOgp(ctx context.Context, params GetOgpParams) (GetOgpRes, error) {
	res, err := c.sendGetOgp(ctx, params)
	return res, err
}

func (c *Client) sendGetOgp(ctx context.Context, params GetOgpParams) (res GetOgpRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ogp"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "url" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.URL))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetOgpOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetOgpOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOgpResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOnlineUsers invokes getOnlineUsers operation.
//
// 現在オンラインな(SSEまたはWSが接続中)ユーザーのUUIDのリストを返します。.
//
// GET /activity/onlines
func (c *Client) GetOnlineUsers(ctx context.Context) ([]string, error) {
	res, err := c.sendGetOnlineUsers(ctx)
	return res, err
}

func (c *Client) sendGetOnlineUsers(ctx context.Context) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/activity/onlines"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetOnlineUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetOnlineUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOnlineUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPin invokes getPin operation.
//
// 指定したメッセージのピン留め情報を取得します。.
//
// GET /messages/{messageId}/pin
func (c *Client) GetPin(ctx context.Context, params GetPinParams) (GetPinRes, error) {
	res, err := c.sendGetPin(ctx, params)
	return res, err
}

func (c *Client) sendGetPin(ctx context.Context, params GetPinParams) (res GetPinRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetPinOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetPinOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPinResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPublicUserIcon invokes getPublicUserIcon operation.
//
// ユーザーのアイコン画像を取得します。.
//
// GET /public/icon/{username}
func (c *Client) GetPublicUserIcon(ctx context.Context, params GetPublicUserIconParams) (GetPublicUserIconRes, error) {
	res, err := c.sendGetPublicUserIcon(ctx, params)
	return res, err
}

func (c *Client) sendGetPublicUserIcon(ctx context.Context, params GetPublicUserIconParams) (res GetPublicUserIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/public/icon/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetPublicUserIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetPublicUserIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPublicUserIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetQallEndpoints invokes getQallEndpoints operation.
//
// 接続可能なLiveKitエンドポイントを取得します。.
//
// GET /qall/endpoints
func (c *Client) GetQallEndpoints(ctx context.Context) (GetQallEndpointsRes, error) {
	res, err := c.sendGetQallEndpoints(ctx)
	return res, err
}

func (c *Client) sendGetQallEndpoints(ctx context.Context) (res GetQallEndpointsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/qall/endpoints"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetQallEndpointsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetQallEndpointsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetQallEndpointsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRoomMetadata invokes getRoomMetadata operation.
//
// ルームのメタデータを取得します。.
//
// GET /qall/rooms/{roomId}/metadata
func (c *Client) GetRoomMetadata(ctx context.Context, params GetRoomMetadataParams) (GetRoomMetadataRes, error) {
	res, err := c.sendGetRoomMetadata(ctx, params)
	return res, err
}

func (c *Client) sendGetRoomMetadata(ctx context.Context, params GetRoomMetadataParams) (res GetRoomMetadataRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/qall/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metadata"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetRoomMetadataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetRoomMetadataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRoomMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetRooms invokes getRooms operation.
//
// 現在存在する(またはアクティブな)ルームと、そのルームに所属している参加者情報を取得します。.
//
// GET /qall/rooms
func (c *Client) GetRooms(ctx context.Context) (GetRoomsRes, error) {
	res, err := c.sendGetRooms(ctx)
	return res, err
}

func (c *Client) sendGetRooms(ctx context.Context) (res GetRoomsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/qall/rooms"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetRoomsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetRoomsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetRoomsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetServerVersion invokes getServerVersion operation.
//
// サーバーバージョン及びサーバーフラグ情報を取得します。.
//
// GET /version
func (c *Client) GetServerVersion(ctx context.Context) (*Version, error) {
	res, err := c.sendGetServerVersion(ctx)
	return res, err
}

func (c *Client) sendGetServerVersion(ctx context.Context) (res *Version, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/version"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetServerVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetServerVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetServerVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetSoundboardList invokes getSoundboardList operation.
//
// DBに保存されたサウンドボード情報を取得します。   各アイテムには
// soundId, soundName, stampId が含まれます。.
//
// GET /qall/soundboard
func (c *Client) GetSoundboardList(ctx context.Context) (GetSoundboardListRes, error) {
	res, err := c.sendGetSoundboardList(ctx)
	return res, err
}

func (c *Client) sendGetSoundboardList(ctx context.Context) (res GetSoundboardListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/qall/soundboard"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetSoundboardListOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetSoundboardListOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetSoundboardListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStamp invokes getStamp operation.
//
// 指定したスタンプの情報を取得します。.
//
// GET /stamps/{stampId}
func (c *Client) GetStamp(ctx context.Context, params GetStampParams) (GetStampRes, error) {
	res, err := c.sendGetStamp(ctx, params)
	return res, err
}

func (c *Client) sendGetStamp(ctx context.Context, params GetStampParams) (res GetStampRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStampResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStampImage invokes getStampImage operation.
//
// 指定したIDのスタンプ画像を返します。.
//
// GET /stamps/{stampId}/image
func (c *Client) GetStampImage(ctx context.Context, params GetStampImageParams) (GetStampImageRes, error) {
	res, err := c.sendGetStampImage(ctx, params)
	return res, err
}

func (c *Client) sendGetStampImage(ctx context.Context, params GetStampImageParams) (res GetStampImageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/image"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetStampImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetStampImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStampImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStampPalette invokes getStampPalette operation.
//
// 指定したスタンプパレットの情報を取得します。.
//
// GET /stamp-palettes/{paletteId}
func (c *Client) GetStampPalette(ctx context.Context, params GetStampPaletteParams) (GetStampPaletteRes, error) {
	res, err := c.sendGetStampPalette(ctx, params)
	return res, err
}

func (c *Client) sendGetStampPalette(ctx context.Context, params GetStampPaletteParams) (res GetStampPaletteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/stamp-palettes/"
	{
		// Encode "paletteId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "paletteId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.PaletteId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetStampPaletteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStampPaletteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStampPalettes invokes getStampPalettes operation.
//
// 自身が所有しているスタンプパレットのリストを取得します。.
//
// GET /stamp-palettes
func (c *Client) GetStampPalettes(ctx context.Context) ([]StampPalette, error) {
	res, err := c.sendGetStampPalettes(ctx)
	return res, err
}

func (c *Client) sendGetStampPalettes(ctx context.Context) (res []StampPalette, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stamp-palettes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetStampPalettesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetStampPalettesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStampPalettesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStampStats invokes getStampStats operation.
//
// 指定したスタンプの統計情報を取得します。.
//
// GET /stamps/{stampId}/stats
func (c *Client) GetStampStats(ctx context.Context, params GetStampStatsParams) (GetStampStatsRes, error) {
	res, err := c.sendGetStampStats(ctx, params)
	return res, err
}

func (c *Client) sendGetStampStats(ctx context.Context, params GetStampStatsParams) (res GetStampStatsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stats"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetStampStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetStampStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStampStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetStamps invokes getStamps operation.
//
// スタンプのリストを取得します。.
//
// GET /stamps
func (c *Client) GetStamps(ctx context.Context, params GetStampsParams) ([]StampWithThumbnail, error) {
	res, err := c.sendGetStamps(ctx, params)
	return res, err
}

func (c *Client) sendGetStamps(ctx context.Context, params GetStampsParams) (res []StampWithThumbnail, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/stamps"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include-unicode" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include-unicode",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeUnicode.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetStampsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetStampsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetStampsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTag invokes getTag operation.
//
// 指定したタグの情報を取得します。.
//
// GET /tags/{tagId}
func (c *Client) GetTag(ctx context.Context, params GetTagParams) (GetTagRes, error) {
	res, err := c.sendGetTag(ctx, params)
	return res, err
}

func (c *Client) sendGetTag(ctx context.Context, params GetTagParams) (res GetTagRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tags/"
	{
		// Encode "tagId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tagId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TagId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetThumbnailImage invokes getThumbnailImage operation.
//
// 指定したファイルのサムネイル画像を取得します。
// 指定したファイルへのアクセス権限が必要です。.
//
// GET /files/{fileId}/thumbnail
func (c *Client) GetThumbnailImage(ctx context.Context, params GetThumbnailImageParams) (GetThumbnailImageRes, error) {
	res, err := c.sendGetThumbnailImage(ctx, params)
	return res, err
}

func (c *Client) sendGetThumbnailImage(ctx context.Context, params GetThumbnailImageParams) (res GetThumbnailImageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/files/"
	{
		// Encode "fileId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "fileId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FileId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/thumbnail"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "type" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "type",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Type.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetThumbnailImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetThumbnailImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetThumbnailImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUser invokes getUser operation.
//
// 指定したユーザーの詳細情報を取得します。.
//
// GET /users/{userId}
func (c *Client) GetUser(ctx context.Context, params GetUserParams) (GetUserRes, error) {
	res, err := c.sendGetUser(ctx, params)
	return res, err
}

func (c *Client) sendGetUser(ctx context.Context, params GetUserParams) (res GetUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserDMChannel invokes getUserDMChannel operation.
//
// 指定したユーザーとのダイレクトメッセージチャンネルの情報を返します。
// ダイレクトメッセージチャンネルが存在しなかった場合、自動的に作成されます。.
//
// GET /users/{userId}/dm-channel
func (c *Client) GetUserDMChannel(ctx context.Context, params GetUserDMChannelParams) (GetUserDMChannelRes, error) {
	res, err := c.sendGetUserDMChannel(ctx, params)
	return res, err
}

func (c *Client) sendGetUserDMChannel(ctx context.Context, params GetUserDMChannelParams) (res GetUserDMChannelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dm-channel"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserDMChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserDMChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserDMChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserGroup invokes getUserGroup operation.
//
// 指定したユーザーグループの情報を取得します。.
//
// GET /groups/{groupId}
func (c *Client) GetUserGroup(ctx context.Context, params GetUserGroupParams) (GetUserGroupRes, error) {
	res, err := c.sendGetUserGroup(ctx, params)
	return res, err
}

func (c *Client) sendGetUserGroup(ctx context.Context, params GetUserGroupParams) (res GetUserGroupRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserGroupOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserGroupResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserGroupAdmins invokes getUserGroupAdmins operation.
//
// 指定したグループの管理者のリストを取得します。.
//
// GET /groups/{groupId}/admins
func (c *Client) GetUserGroupAdmins(ctx context.Context, params GetUserGroupAdminsParams) (GetUserGroupAdminsRes, error) {
	res, err := c.sendGetUserGroupAdmins(ctx, params)
	return res, err
}

func (c *Client) sendGetUserGroupAdmins(ctx context.Context, params GetUserGroupAdminsParams) (res GetUserGroupAdminsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/admins"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserGroupAdminsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserGroupAdminsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserGroupAdminsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserGroupMembers invokes getUserGroupMembers operation.
//
// 指定したグループのメンバーのリストを取得します。.
//
// GET /groups/{groupId}/members
func (c *Client) GetUserGroupMembers(ctx context.Context, params GetUserGroupMembersParams) (GetUserGroupMembersRes, error) {
	res, err := c.sendGetUserGroupMembers(ctx, params)
	return res, err
}

func (c *Client) sendGetUserGroupMembers(ctx context.Context, params GetUserGroupMembersParams) (res GetUserGroupMembersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserGroupMembersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserGroupMembersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserGroupMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserGroups invokes getUserGroups operation.
//
// ユーザーグループのリストを取得します。.
//
// GET /groups
func (c *Client) GetUserGroups(ctx context.Context) ([]UserGroup, error) {
	res, err := c.sendGetUserGroups(ctx)
	return res, err
}

func (c *Client) sendGetUserGroups(ctx context.Context) (res []UserGroup, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/groups"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserGroupsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserGroupsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserGroupsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserIcon invokes getUserIcon operation.
//
// 指定したユーザーのアイコン画像を取得します。.
//
// GET /users/{userId}/icon
func (c *Client) GetUserIcon(ctx context.Context, params GetUserIconParams) (GetUserIconRes, error) {
	res, err := c.sendGetUserIcon(ctx, params)
	return res, err
}

func (c *Client) sendGetUserIcon(ctx context.Context, params GetUserIconParams) (res GetUserIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/icon"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserSettings invokes getUserSettings operation.
//
// ユーザー設定を取得します。.
//
// GET /users/me/settings
func (c *Client) GetUserSettings(ctx context.Context) (*UserSettings, error) {
	res, err := c.sendGetUserSettings(ctx)
	return res, err
}

func (c *Client) sendGetUserSettings(ctx context.Context) (res *UserSettings, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/settings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserStats invokes getUserStats operation.
//
// 指定したユーザーの統計情報を取得します。.
//
// GET /users/{userId}/stats
func (c *Client) GetUserStats(ctx context.Context, params GetUserStatsParams) (GetUserStatsRes, error) {
	res, err := c.sendGetUserStats(ctx, params)
	return res, err
}

func (c *Client) sendGetUserStats(ctx context.Context, params GetUserStatsParams) (res GetUserStatsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stats"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserTags invokes getUserTags operation.
//
// 指定したユーザーのタグリストを取得します。.
//
// GET /users/{userId}/tags
func (c *Client) GetUserTags(ctx context.Context, params GetUserTagsParams) (GetUserTagsRes, error) {
	res, err := c.sendGetUserTags(ctx, params)
	return res, err
}

func (c *Client) sendGetUserTags(ctx context.Context, params GetUserTagsParams) (res GetUserTagsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUserTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUserTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsers invokes getUsers operation.
//
// ユーザーのリストを取得します。
// `include-suspended`を指定しない場合、レスポンスにはユーザーアカウント状態が"1: 有効"であるユーザーのみが含まれます。
// `include-suspended`と`name`を同時に指定することはできません。.
//
// GET /users
func (c *Client) GetUsers(ctx context.Context, params GetUsersParams) (GetUsersRes, error) {
	res, err := c.sendGetUsers(ctx, params)
	return res, err
}

func (c *Client) sendGetUsers(ctx context.Context, params GetUsersParams) (res GetUsersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "include-suspended" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "include-suspended",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IncludeSuspended.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebRTCState invokes getWebRTCState operation.
//
// 現在のWebRTC状態を取得します。.
//
// GET /webrtc/state
func (c *Client) GetWebRTCState(ctx context.Context) (WebRTCUserStates, error) {
	res, err := c.sendGetWebRTCState(ctx)
	return res, err
}

func (c *Client) sendGetWebRTCState(ctx context.Context) (res WebRTCUserStates, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/webrtc/state"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetWebRTCStateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetWebRTCStateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebRTCStateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhook invokes getWebhook operation.
//
// 指定したWebhookの詳細を取得します。.
//
// GET /webhooks/{webhookId}
func (c *Client) GetWebhook(ctx context.Context, params GetWebhookParams) (GetWebhookRes, error) {
	res, err := c.sendGetWebhook(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhook(ctx context.Context, params GetWebhookParams) (res GetWebhookRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/webhooks/"
	{
		// Encode "webhookId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhookId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WebhookId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookIcon invokes getWebhookIcon operation.
//
// 指定したWebhookのアイコン画像を取得します.
//
// GET /webhooks/{webhookId}/icon
func (c *Client) GetWebhookIcon(ctx context.Context, params GetWebhookIconParams) (GetWebhookIconRes, error) {
	res, err := c.sendGetWebhookIcon(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhookIcon(ctx context.Context, params GetWebhookIconParams) (res GetWebhookIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/webhooks/"
	{
		// Encode "webhookId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhookId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WebhookId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/icon"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetWebhookIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetWebhookIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhookMessages invokes getWebhookMessages operation.
//
// 指定されたWebhookが投稿したメッセージのリストを返します。.
//
// GET /webhooks/{webhookId}/messages
func (c *Client) GetWebhookMessages(ctx context.Context, params GetWebhookMessagesParams) (GetWebhookMessagesRes, error) {
	res, err := c.sendGetWebhookMessages(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhookMessages(ctx context.Context, params GetWebhookMessagesParams) (res GetWebhookMessagesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/webhooks/"
	{
		// Encode "webhookId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhookId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WebhookId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "since" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "since",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Since.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "until" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "until",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Until.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "inclusive" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "inclusive",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Inclusive.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Order.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetWebhookMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetWebhookMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhookMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetWebhooks invokes getWebhooks operation.
//
// Webhookのリストを取得します。
// allがtrueで無い場合は、自分がオーナーのWebhookのリストを返します。.
//
// GET /webhooks
func (c *Client) GetWebhooks(ctx context.Context, params GetWebhooksParams) ([]Webhook, error) {
	res, err := c.sendGetWebhooks(ctx, params)
	return res, err
}

func (c *Client) sendGetWebhooks(ctx context.Context, params GetWebhooksParams) (res []Webhook, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/webhooks"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "all" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, GetWebhooksOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, GetWebhooksOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetWebhooksResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InactivateBot invokes inactivateBot operation.
//
// 指定したBOTを無効化します。対象のBOTの管理権限が必要です。.
//
// POST /bots/{botId}/actions/inactivate
func (c *Client) InactivateBot(ctx context.Context, params InactivateBotParams) (InactivateBotRes, error) {
	res, err := c.sendInactivateBot(ctx, params)
	return res, err
}

func (c *Client) sendInactivateBot(ctx context.Context, params InactivateBotParams) (res InactivateBotRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/inactivate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, InactivateBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, InactivateBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeInactivateBotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LetBotJoinChannel invokes letBotJoinChannel operation.
//
// 指定したBOTを指定したチャンネルに参加させます。
// チャンネルに参加したBOTは、そのチャンネルの各種イベントを受け取るようになります。
// 対象のBOTの管理権限が必要です。.
//
// POST /bots/{botId}/actions/join
func (c *Client) LetBotJoinChannel(ctx context.Context, request OptPostBotActionJoinRequest, params LetBotJoinChannelParams) (LetBotJoinChannelRes, error) {
	res, err := c.sendLetBotJoinChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendLetBotJoinChannel(ctx context.Context, request OptPostBotActionJoinRequest, params LetBotJoinChannelParams) (res LetBotJoinChannelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/join"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLetBotJoinChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, LetBotJoinChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, LetBotJoinChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLetBotJoinChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LetBotLeaveChannel invokes letBotLeaveChannel operation.
//
// 指定したBOTを指定したチャンネルから退出させます。
// 対象のBOTの管理権限が必要です。.
//
// POST /bots/{botId}/actions/leave
func (c *Client) LetBotLeaveChannel(ctx context.Context, request OptPostBotActionLeaveRequest, params LetBotLeaveChannelParams) (LetBotLeaveChannelRes, error) {
	res, err := c.sendLetBotLeaveChannel(ctx, request, params)
	return res, err
}

func (c *Client) sendLetBotLeaveChannel(ctx context.Context, request OptPostBotActionLeaveRequest, params LetBotLeaveChannelParams) (res LetBotLeaveChannelRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/leave"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLetBotLeaveChannelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, LetBotLeaveChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, LetBotLeaveChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLetBotLeaveChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LinkExternalAccount invokes linkExternalAccount operation.
//
// 自分に外部ログインアカウントを紐付けます。
// 指定した`providerName`がサーバー側で有効である必要があります。
// リクエストが受理された場合、外部サービスの認証画面にリダイレクトされ、認証される必要があります。.
//
// POST /users/me/ex-accounts/link
func (c *Client) LinkExternalAccount(ctx context.Context, request OptPostLinkExternalAccount) (LinkExternalAccountRes, error) {
	res, err := c.sendLinkExternalAccount(ctx, request)
	return res, err
}

func (c *Client) sendLinkExternalAccount(ctx context.Context, request OptPostLinkExternalAccount) (res LinkExternalAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/ex-accounts/link"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLinkExternalAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, LinkExternalAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, LinkExternalAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLinkExternalAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Login invokes login operation.
//
// ログインします。.
//
// POST /login
func (c *Client) Login(ctx context.Context, request OptPostLoginRequest, params LoginParams) (LoginRes, error) {
	res, err := c.sendLogin(ctx, request, params)
	return res, err
}

func (c *Client) sendLogin(ctx context.Context, request OptPostLoginRequest, params LoginParams) (res LoginRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/login"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "redirect" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redirect",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Redirect.Get(); ok {
				return e.EncodeValue(conv.URLToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, LoginOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, LoginOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Logout invokes logout operation.
//
// ログアウトします。.
//
// POST /logout
func (c *Client) Logout(ctx context.Context, params LogoutParams) (LogoutRes, error) {
	res, err := c.sendLogout(ctx, params)
	return res, err
}

func (c *Client) sendLogout(ctx context.Context, params LogoutParams) (res LogoutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/logout"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "redirect" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "redirect",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Redirect.Get(); ok {
				return e.EncodeValue(conv.URLToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "all" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "all",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.All.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, LogoutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, LogoutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLogoutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostDirectMessage invokes postDirectMessage operation.
//
// 指定したユーザーにダイレクトメッセージを送信します。.
//
// POST /users/{userId}/messages
func (c *Client) PostDirectMessage(ctx context.Context, request OptPostMessageRequest, params PostDirectMessageParams) (PostDirectMessageRes, error) {
	res, err := c.sendPostDirectMessage(ctx, request, params)
	return res, err
}

func (c *Client) sendPostDirectMessage(ctx context.Context, request OptPostMessageRequest, params PostDirectMessageParams) (res PostDirectMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostDirectMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostDirectMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostDirectMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostDirectMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostFile invokes postFile operation.
//
// 指定したチャンネルにファイルをアップロードします。
// アーカイブされているチャンネルにはアップロード出来ません。.
//
// POST /files
func (c *Client) PostFile(ctx context.Context, request OptPostFileRequestMultipart) (PostFileRes, error) {
	res, err := c.sendPostFile(ctx, request)
	return res, err
}

func (c *Client) sendPostFile(ctx context.Context, request OptPostFileRequestMultipart) (res PostFileRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/files"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostFileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostFileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostFileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostFileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostMessage invokes postMessage operation.
//
// 指定したチャンネルにメッセージを投稿します。
// embedをtrueに指定すると、メッセージ埋め込みが自動で行われます。
// アーカイブされているチャンネルに投稿することはできません。.
//
// POST /channels/{channelId}/messages
func (c *Client) PostMessage(ctx context.Context, request OptPostMessageRequest, params PostMessageParams) (PostMessageRes, error) {
	res, err := c.sendPostMessage(ctx, request, params)
	return res, err
}

func (c *Client) sendPostMessage(ctx context.Context, request OptPostMessageRequest, params PostMessageParams) (res PostMessageRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostOAuth2Authorize invokes postOAuth2Authorize operation.
//
// OAuth2 認可エンドポイント.
//
// POST /oauth2/authorize
func (c *Client) PostOAuth2Authorize(ctx context.Context, request *OAuth2Authorization) (PostOAuth2AuthorizeRes, error) {
	res, err := c.sendPostOAuth2Authorize(ctx, request)
	return res, err
}

func (c *Client) sendPostOAuth2Authorize(ctx context.Context, request *OAuth2Authorization) (res PostOAuth2AuthorizeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/oauth2/authorize"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostOAuth2AuthorizeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostOAuth2AuthorizeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostOAuth2AuthorizeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostOAuth2AuthorizeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostOAuth2AuthorizeDecide invokes postOAuth2AuthorizeDecide operation.
//
// OAuth2 認可承諾.
//
// POST /oauth2/authorize/decide
func (c *Client) PostOAuth2AuthorizeDecide(ctx context.Context, request *OAuth2Decide) (PostOAuth2AuthorizeDecideRes, error) {
	res, err := c.sendPostOAuth2AuthorizeDecide(ctx, request)
	return res, err
}

func (c *Client) sendPostOAuth2AuthorizeDecide(ctx context.Context, request *OAuth2Decide) (res PostOAuth2AuthorizeDecideRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/oauth2/authorize/decide"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostOAuth2AuthorizeDecideRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostOAuth2AuthorizeDecideOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostOAuth2AuthorizeDecideOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostOAuth2AuthorizeDecideResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostOAuth2Token invokes postOAuth2Token operation.
//
// OAuth2 トークンエンドポイント.
//
// POST /oauth2/token
func (c *Client) PostOAuth2Token(ctx context.Context, request *PostOAuth2Token) (PostOAuth2TokenRes, error) {
	res, err := c.sendPostOAuth2Token(ctx, request)
	return res, err
}

func (c *Client) sendPostOAuth2Token(ctx context.Context, request *PostOAuth2Token) (res PostOAuth2TokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/oauth2/token"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostOAuth2TokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostOAuth2TokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostOAuth2TokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostOAuth2TokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostSoundboard invokes postSoundboard operation.
//
// 15秒程度の短い音声ファイルを multipart/form-data
// で送信し、S3(互換ストレージ)にアップロードします。
// クライアントは「soundName」というフィールドを送信し、それをDBに保存して関連付けを行います。   また、サーバ側で soundId を自動生成し、S3のファイル名に使用します。.
//
// POST /qall/soundboard
func (c *Client) PostSoundboard(ctx context.Context, request *SoundboardUploadRequestMultipart) (PostSoundboardRes, error) {
	res, err := c.sendPostSoundboard(ctx, request)
	return res, err
}

func (c *Client) sendPostSoundboard(ctx context.Context, request *SoundboardUploadRequestMultipart) (res PostSoundboardRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/qall/soundboard"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostSoundboardRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostSoundboardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostSoundboardOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostSoundboardResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostSoundboardPlay invokes postSoundboardPlay operation.
//
// S3上にある音声ファイルの署名付きURLを生成し、
// Ingressを介して指定ルームに音声を流します。
// 該当ルームに参加しているユーザであれば再生可能とします。.
//
// POST /qall/soundboard/play
func (c *Client) PostSoundboardPlay(ctx context.Context, request *SoundboardPlayRequest) (PostSoundboardPlayRes, error) {
	res, err := c.sendPostSoundboardPlay(ctx, request)
	return res, err
}

func (c *Client) sendPostSoundboardPlay(ctx context.Context, request *SoundboardPlayRequest) (res PostSoundboardPlayRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/qall/soundboard/play"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostSoundboardPlayRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostSoundboardPlayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostSoundboardPlayOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostSoundboardPlayResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostWebRTCAuthenticate invokes postWebRTCAuthenticate operation.
//
// Skyway WebRTC用の認証API.
//
// POST /webrtc/authenticate
func (c *Client) PostWebRTCAuthenticate(ctx context.Context, request OptPostWebRTCAuthenticateRequest) (PostWebRTCAuthenticateRes, error) {
	res, err := c.sendPostWebRTCAuthenticate(ctx, request)
	return res, err
}

func (c *Client) sendPostWebRTCAuthenticate(ctx context.Context, request OptPostWebRTCAuthenticateRequest) (res PostWebRTCAuthenticateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/webrtc/authenticate"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostWebRTCAuthenticateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostWebRTCAuthenticateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostWebRTCAuthenticateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostWebRTCAuthenticateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PostWebhook invokes postWebhook operation.
//
// Webhookにメッセージを投稿します。
// secureなウェブフックに対しては`X-TRAQ-Signature`ヘッダーが必須です。
// アーカイブされているチャンネルには投稿できません。.
//
// POST /webhooks/{webhookId}
func (c *Client) PostWebhook(ctx context.Context, request PostWebhookReq, params PostWebhookParams) (PostWebhookRes, error) {
	res, err := c.sendPostWebhook(ctx, request, params)
	return res, err
}

func (c *Client) sendPostWebhook(ctx context.Context, request PostWebhookReq, params PostWebhookParams) (res PostWebhookRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/webhooks/"
	{
		// Encode "webhookId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "webhookId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.WebhookId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "embed" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "embed",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Embed.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePostWebhookRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	h := uri.NewHeaderEncoder(r.Header)
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "X-TRAQ-Signature",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XTRAQSignature.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}
	{
		cfg := uri.HeaderParameterEncodingConfig{
			Name:    "X-TRAQ-Channel-Id",
			Explode: false,
		}
		if err := h.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.XTRAQChannelID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode header")
		}
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, PostWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, PostWebhookOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePostWebhookResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReadChannel invokes readChannel operation.
//
// 自分が未読のチャンネルを既読にします。.
//
// DELETE /users/me/unread/{channelId}
func (c *Client) ReadChannel(ctx context.Context, params ReadChannelParams) error {
	_, err := c.sendReadChannel(ctx, params)
	return err
}

func (c *Client) sendReadChannel(ctx context.Context, params ReadChannelParams) (res *ReadChannelNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/me/unread/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ReadChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ReadChannelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReadChannelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RegisterFCMDevice invokes registerFCMDevice operation.
//
// 自身のFCMデバイスを登録します。.
//
// POST /users/me/fcm-device
func (c *Client) RegisterFCMDevice(ctx context.Context, request OptPostMyFCMDeviceRequest) (RegisterFCMDeviceRes, error) {
	res, err := c.sendRegisterFCMDevice(ctx, request)
	return res, err
}

func (c *Client) sendRegisterFCMDevice(ctx context.Context, request OptPostMyFCMDeviceRequest) (res RegisterFCMDeviceRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/fcm-device"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRegisterFCMDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RegisterFCMDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RegisterFCMDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRegisterFCMDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReissueBot invokes reissueBot operation.
//
// 指定したBOTの現在の各種トークンを無効化し、再発行を行います。
// 対象のBOTの管理権限が必要です。.
//
// POST /bots/{botId}/actions/reissue
func (c *Client) ReissueBot(ctx context.Context, params ReissueBotParams) (ReissueBotRes, error) {
	res, err := c.sendReissueBot(ctx, params)
	return res, err
}

func (c *Client) sendReissueBot(ctx context.Context, params ReissueBotParams) (res ReissueBotRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/bots/"
	{
		// Encode "botId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "botId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.BotId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/reissue"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, ReissueBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, ReissueBotOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReissueBotResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveMessageStamp invokes removeMessageStamp operation.
//
// 指定したメッセージから指定した自身が押したスタンプを削除します。.
//
// DELETE /messages/{messageId}/stamps/{stampId}
func (c *Client) RemoveMessageStamp(ctx context.Context, params RemoveMessageStampParams) (RemoveMessageStampRes, error) {
	res, err := c.sendRemoveMessageStamp(ctx, params)
	return res, err
}

func (c *Client) sendRemoveMessageStamp(ctx context.Context, params RemoveMessageStampParams) (res RemoveMessageStampRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/stamps/"
	{
		// Encode "stampId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "stampId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.StampId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemoveMessageStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemoveMessageStampOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveMessageStampResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveMyStar invokes removeMyStar operation.
//
// 既にスターから削除されているチャンネルを指定した場合は204を返します。.
//
// DELETE /users/me/stars/{channelId}
func (c *Client) RemoveMyStar(ctx context.Context, params RemoveMyStarParams) error {
	_, err := c.sendRemoveMyStar(ctx, params)
	return err
}

func (c *Client) sendRemoveMyStar(ctx context.Context, params RemoveMyStarParams) (res *RemoveMyStarNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/me/stars/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemoveMyStarOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemoveMyStarOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveMyStarResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveMyUserTag invokes removeMyUserTag operation.
//
// 既に存在しないタグを削除しようとした場合は204を返します。.
//
// DELETE /users/me/tags/{tagId}
func (c *Client) RemoveMyUserTag(ctx context.Context, params RemoveMyUserTagParams) (RemoveMyUserTagRes, error) {
	res, err := c.sendRemoveMyUserTag(ctx, params)
	return res, err
}

func (c *Client) sendRemoveMyUserTag(ctx context.Context, params RemoveMyUserTagParams) (res RemoveMyUserTagRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/me/tags/"
	{
		// Encode "tagId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tagId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TagId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemoveMyUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemoveMyUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveMyUserTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemovePin invokes removePin operation.
//
// 指定したメッセージのピン留めを外します。.
//
// DELETE /messages/{messageId}/pin
func (c *Client) RemovePin(ctx context.Context, params RemovePinParams) (RemovePinRes, error) {
	res, err := c.sendRemovePin(ctx, params)
	return res, err
}

func (c *Client) sendRemovePin(ctx context.Context, params RemovePinParams) (res RemovePinRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/pin"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemovePinOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemovePinOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemovePinResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveUserGroupAdmin invokes removeUserGroupAdmin operation.
//
// 指定したユーザーグループから指定した管理者を削除します。
// 対象のユーザーグループの管理者権限が必要です。
// グループから管理者が存在しなくなる場合は400エラーを返します。.
//
// DELETE /groups/{groupId}/admins/{userId}
func (c *Client) RemoveUserGroupAdmin(ctx context.Context, params RemoveUserGroupAdminParams) (RemoveUserGroupAdminRes, error) {
	res, err := c.sendRemoveUserGroupAdmin(ctx, params)
	return res, err
}

func (c *Client) sendRemoveUserGroupAdmin(ctx context.Context, params RemoveUserGroupAdminParams) (res RemoveUserGroupAdminRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/admins/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemoveUserGroupAdminOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemoveUserGroupAdminOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveUserGroupAdminResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveUserGroupMember invokes removeUserGroupMember operation.
//
// 指定したユーザーグループから指定したユーザーを削除します。
// 既にグループから削除されているメンバーを指定した場合は204を返します。
// 対象のユーザーグループの管理者権限が必要です。.
//
// DELETE /groups/{groupId}/members/{userId}
func (c *Client) RemoveUserGroupMember(ctx context.Context, params RemoveUserGroupMemberParams) (RemoveUserGroupMemberRes, error) {
	res, err := c.sendRemoveUserGroupMember(ctx, params)
	return res, err
}

func (c *Client) sendRemoveUserGroupMember(ctx context.Context, params RemoveUserGroupMemberParams) (res RemoveUserGroupMemberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemoveUserGroupMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemoveUserGroupMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveUserGroupMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveUserGroupMembers invokes removeUserGroupMembers operation.
//
// 指定したグループから全てのメンバーを削除します。
// 対象のユーザーグループの管理者権限が必要です。.
//
// DELETE /groups/{groupId}/members
func (c *Client) RemoveUserGroupMembers(ctx context.Context, params RemoveUserGroupMembersParams) (RemoveUserGroupMembersRes, error) {
	res, err := c.sendRemoveUserGroupMembers(ctx, params)
	return res, err
}

func (c *Client) sendRemoveUserGroupMembers(ctx context.Context, params RemoveUserGroupMembersParams) (res RemoveUserGroupMembersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/groups/"
	{
		// Encode "groupId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "groupId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.GroupId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemoveUserGroupMembersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemoveUserGroupMembersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveUserGroupMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemoveUserTag invokes removeUserTag operation.
//
// 既に存在しないタグを削除しようとした場合は204を返します。.
//
// DELETE /users/{userId}/tags/{tagId}
func (c *Client) RemoveUserTag(ctx context.Context, params RemoveUserTagParams) (RemoveUserTagRes, error) {
	res, err := c.sendRemoveUserTag(ctx, params)
	return res, err
}

func (c *Client) sendRemoveUserTag(ctx context.Context, params RemoveUserTagParams) (res RemoveUserTagRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/users/"
	{
		// Encode "userId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.UserId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tags/"
	{
		// Encode "tagId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tagId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TagId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RemoveUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RemoveUserTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRemoveUserTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeClientTokens invokes revokeClientTokens operation.
//
// 自分が許可している指定したOAuthクライアントのアクセストークンを全てRevokeします。.
//
// DELETE /clients/{clientId}/tokens
func (c *Client) RevokeClientTokens(ctx context.Context, params RevokeClientTokensParams) (RevokeClientTokensRes, error) {
	res, err := c.sendRevokeClientTokens(ctx, params)
	return res, err
}

func (c *Client) sendRevokeClientTokens(ctx context.Context, params RevokeClientTokensParams) (res RevokeClientTokensRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/clients/"
	{
		// Encode "clientId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clientId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ClientId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RevokeClientTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RevokeClientTokensOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRevokeClientTokensResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeMySession invokes revokeMySession operation.
//
// 指定した自分のセッションを無効化(ログアウト)します。
// 既に存在しない・無効化されているセッションを指定した場合も`204`を返します。.
//
// DELETE /users/me/sessions/{sessionId}
func (c *Client) RevokeMySession(ctx context.Context, params RevokeMySessionParams) error {
	_, err := c.sendRevokeMySession(ctx, params)
	return err
}

func (c *Client) sendRevokeMySession(ctx context.Context, params RevokeMySessionParams) (res *RevokeMySessionNoContent, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/me/sessions/"
	{
		// Encode "sessionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "sessionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.SessionId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RevokeMySessionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RevokeMySessionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRevokeMySessionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeMyToken invokes revokeMyToken operation.
//
// 自分の指定したトークンの認可を取り消します。.
//
// DELETE /users/me/tokens/{tokenId}
func (c *Client) RevokeMyToken(ctx context.Context, params RevokeMyTokenParams) (RevokeMyTokenRes, error) {
	res, err := c.sendRevokeMyToken(ctx, params)
	return res, err
}

func (c *Client) sendRevokeMyToken(ctx context.Context, params RevokeMyTokenParams) (res RevokeMyTokenRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/me/tokens/"
	{
		// Encode "tokenId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tokenId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.TokenId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RevokeMyTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RevokeMyTokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRevokeMyTokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RevokeOAuth2Token invokes revokeOAuth2Token operation.
//
// OAuth2 トークン無効化エンドポイント.
//
// POST /oauth2/revoke
func (c *Client) RevokeOAuth2Token(ctx context.Context, request *OAuth2Revoke) error {
	_, err := c.sendRevokeOAuth2Token(ctx, request)
	return err
}

func (c *Client) sendRevokeOAuth2Token(ctx context.Context, request *OAuth2Revoke) (res *RevokeOAuth2TokenOK, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/oauth2/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRevokeOAuth2TokenRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, RevokeOAuth2TokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, RevokeOAuth2TokenOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRevokeOAuth2TokenResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchMessages invokes searchMessages operation.
//
// メッセージを検索します。.
//
// GET /messages
func (c *Client) SearchMessages(ctx context.Context, params SearchMessagesParams) (SearchMessagesRes, error) {
	res, err := c.sendSearchMessages(ctx, params)
	return res, err
}

func (c *Client) sendSearchMessages(ctx context.Context, params SearchMessagesParams) (res SearchMessagesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/messages"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "word" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "word",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Word.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "after" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "before" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "before",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Before.Get(); ok {
				return e.EncodeValue(conv.DateTimeToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "in" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "in",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.In.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "to" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.To != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.To {
						if err := func() error {
							return e.EncodeValue(conv.UUIDToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "from" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if params.From != nil {
				return e.EncodeArray(func(e uri.Encoder) error {
					for i, item := range params.From {
						if err := func() error {
							return e.EncodeValue(conv.UUIDToString(item))
						}(); err != nil {
							return errors.Wrapf(err, "[%d]", i)
						}
					}
					return nil
				})
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "citation" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "citation",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Citation.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "bot" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "bot",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Bot.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hasURL" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hasURL",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HasURL.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hasAttachments" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hasAttachments",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HasAttachments.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hasImage" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hasImage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HasImage.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hasVideo" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hasVideo",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HasVideo.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "hasAudio" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "hasAudio",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.HasAudio.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "sort" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "sort",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Sort.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, SearchMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, SearchMessagesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchMessagesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChannelSubscribeLevel invokes setChannelSubscribeLevel operation.
//
// 自身の指定したチャンネルの購読レベルを設定します。.
//
// PUT /users/me/subscriptions/{channelId}
func (c *Client) SetChannelSubscribeLevel(ctx context.Context, request OptPutChannelSubscribeLevelRequest, params SetChannelSubscribeLevelParams) (SetChannelSubscribeLevelRes, error) {
	res, err := c.sendSetChannelSubscribeLevel(ctx, request, params)
	return res, err
}

func (c *Client) sendSetChannelSubscribeLevel(ctx context.Context, request OptPutChannelSubscribeLevelRequest, params SetChannelSubscribeLevelParams) (res SetChannelSubscribeLevelRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/users/me/subscriptions/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChannelSubscribeLevelRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, SetChannelSubscribeLevelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, SetChannelSubscribeLevelOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChannelSubscribeLevelResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SetChannelSubscribers invokes setChannelSubscribers operation.
//
// 指定したチャンネルの通知購読者を設定します。
// リクエストに含めなかったユーザーの通知購読状態はオフになります。
// また、存在しないユーザーを指定した場合は無視されます。.
//
// PUT /channels/{channelId}/subscribers
func (c *Client) SetChannelSubscribers(ctx context.Context, request OptPutChannelSubscribersRequest, params SetChannelSubscribersParams) (SetChannelSubscribersRes, error) {
	res, err := c.sendSetChannelSubscribers(ctx, request, params)
	return res, err
}

func (c *Client) sendSetChannelSubscribers(ctx context.Context, request OptPutChannelSubscribersRequest, params SetChannelSubscribersParams) (res SetChannelSubscribersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if value, ok := request.Get(); ok {
			if err := func() error {
				if err := value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/channels/"
	{
		// Encode "channelId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "channelId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.ChannelId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscribers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSetChannelSubscribersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, SetChannelSubscribersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, SetChannelSubscribersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSetChannelSubscribersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnclipMessage invokes unclipMessage operation.
//
// 指定したフォルダから指定したメッセージのクリップを除外します。
// 既に外されているメッセージを指定した場合は204を返します。.
//
// DELETE /clip-folders/{folderId}/messages/{messageId}
func (c *Client) UnclipMessage(ctx context.Context, params UnclipMessageParams) (UnclipMessageRes, error) {
	res, err := c.sendUnclipMessage(ctx, params)
	return res, err
}

func (c *Client) sendUnclipMessage(ctx context.Context, params UnclipMessageParams) (res UnclipMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/clip-folders/"
	{
		// Encode "folderId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "folderId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.FolderId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/messages/"
	{
		// Encode "messageId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "messageId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.MessageId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, UnclipMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, UnclipMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnclipMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnlinkExternalAccount invokes unlinkExternalAccount operation.
//
// 自分に紐付けられている外部ログインアカウントの紐付けを解除します。.
//
// POST /users/me/ex-accounts/unlink
func (c *Client) UnlinkExternalAccount(ctx context.Context, request OptPostUnlinkExternalAccount) (UnlinkExternalAccountRes, error) {
	res, err := c.sendUnlinkExternalAccount(ctx, request)
	return res, err
}

func (c *Client) sendUnlinkExternalAccount(ctx context.Context, request OptPostUnlinkExternalAccount) (res UnlinkExternalAccountRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users/me/ex-accounts/unlink"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUnlinkExternalAccountRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, UnlinkExternalAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, UnlinkExternalAccountOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnlinkExternalAccountResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UpdateRoomMetadata invokes updateRoomMetadata operation.
//
// ルームのメタデータを更新します。.
//
// PATCH /qall/rooms/{roomId}/metadata
func (c *Client) UpdateRoomMetadata(ctx context.Context, request *QallMetadataRequest, params UpdateRoomMetadataParams) (UpdateRoomMetadataRes, error) {
	res, err := c.sendUpdateRoomMetadata(ctx, request, params)
	return res, err
}

func (c *Client) sendUpdateRoomMetadata(ctx context.Context, request *QallMetadataRequest, params UpdateRoomMetadataParams) (res UpdateRoomMetadataRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/qall/rooms/"
	{
		// Encode "roomId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "roomId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.UUIDToString(params.RoomId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/metadata"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUpdateRoomMetadataRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, UpdateRoomMetadataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, UpdateRoomMetadataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUpdateRoomMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Ws invokes ws operation.
//
// # WebSocketプロトコル
// ## 送信
// `コマンド:引数1:引数2:...
// `のような形式のTextMessageをサーバーに送信することで、このWebSocketセッションに対する設定が実行できる。
// ### `viewstate`コマンド
// このWebSocketセッションが見ているチャンネル(イベントを受け取るチャンネル)を設定する。
// 現時点では1つのセッションに対して1つのチャンネルしか設定できない。
// `viewstate:{チャンネルID}:{閲覧状態}`
// + チャンネルID: 対象のチャンネルID
// + 閲覧状態: `none`, `monitoring`, `editing`
// 最初の`viewstate`コマンドを送る前、または`viewstate:null`,
// `viewstate:`を送信した後は、このセッションはどこのチャンネルも見ていないことになる。
// ### `rtcstate`コマンド
// 自分のWebRTC状態を変更する。
// 他のコネクションが既に状態を保持している場合、変更することができません。
// `rtcstate:{チャンネルID}:({状態}:{セッションID})*`
// コネクションが切断された場合、自分のWebRTC状態はリセットされます。
// ### `timeline_streaming`コマンド
// 全てのパブリックチャンネルの`MESSAGE_CREATED`イベントを受け取るかどうかを設定する。
// 初期状態は`off`です。
// `timeline_streaming:(on|off|true|false)`
// ## 受信
// TextMessageとして各種イベントが`type`と`body`を持つJSONとして非同期に送られます。
// 例:
// ```json
// {"type":"USER_ONLINE","body":{"id":"7dd8e07f-7f5d-4331-9176-b56a4299768b"}}
// ```
// ## イベント一覧
// ### `USER_JOINED`
// ユーザーが新規登録された。
// 対象: 全員
// + `id`: 登録されたユーザーのId
// ### `USER_UPDATED`
// ユーザーの情報が更新された。
// 対象: 全員
// + `id`: 情報が更新されたユーザーのId
// ### `USER_TAGS_UPDATED`
// ユーザーのタグが更新された。
// 対象: 全員
// + `id`: タグが更新されたユーザーのId
// + `tag_id`: 更新されたタグのId
// ### `USER_ICON_UPDATED`
// ユーザーのアイコンが更新された。
// 対象: 全員
// + `id`: アイコンが更新されたユーザーのId
// ### `USER_WEBRTC_STATE_CHANGED`
// ユーザーのWebRTCの状態が変化した
// 対象: 全員
// + `user_id`: 変更があったユーザーのId
// + `channel_id`: ユーザーの変更後の接続チャンネルのId
// + `sessions`: ユーザーの変更後の状態(配列)
// + `state`: 状態
// + `sessionId`: セッションID
// ### `USER_VIEWSTATE_CHANGED`
// ユーザーのチャンネルの閲覧状態が変化した
// 対象: 変化したWSセッションを含めた、該当ユーザーのWSセッション全て
// + `view_states`:
// 変化したWSセッションを含めた、該当ユーザーの変更後の状態(配列)
// + `key`: WSセッションの識別子
// + `channel_id`: 閲覧しているチャンネルId
// + `state`: 閲覧状態
// ### `USER_ONLINE`
// ユーザーがオンラインになった。
// 対象: 全員
// + `id`: オンラインになったユーザーのId
// ### `USER_OFFLINE`
// ユーザーがオフラインになった。
// 対象: 全員
// + `id`: オフラインになったユーザーのId
// ### `USER_GROUP_CREATED`
// ユーザーグループが作成された
// 対象: 全員
// + `id`: 作成されたユーザーグループのId
// ### `USER_GROUP_UPDATED`
// ユーザーグループが更新された
// 対象: 全員
// + `id`: 作成されたユーザーグループのId
// ### `USER_GROUP_DELETED`
// ユーザーグループが削除された
// 対象: 全員
// + `id`: 削除されたユーザーグループのId
// ### `CHANNEL_CREATED`
// チャンネルが新規作成された。
// 対象: 該当チャンネルを閲覧可能な全員
// + `id`: 作成されたチャンネルのId
// + `dm_user_id`: (DMの場合のみ) DM相手のユーザーId
// ### `CHANNEL_UPDATED`
// チャンネルの情報が変更された。
// 対象: 該当チャンネルを閲覧可能な全員
// + `id`: 変更があったチャンネルのId
// + `dm_user_id`: (DMの場合のみ) DM相手のユーザーId
// ### `CHANNEL_DELETED`
// チャンネルが削除された。
// 対象: 該当チャンネルを閲覧可能な全員
// + `id`: 削除されたチャンネルのId
// + `dm_user_id`: (DMの場合のみ) DM相手のユーザーId
// ### `CHANNEL_STARED`
// 自分がチャンネルをスターした。
// 対象: 自分
// + `id`: スターしたチャンネルのId
// ### `CHANNEL_UNSTARED`
// 自分がチャンネルのスターを解除した。
// 対象: 自分
// + `id`: スターしたチャンネルのId
// ### `CHANNEL_VIEWERS_CHANGED`
// チャンネルの閲覧者が変化した。
// 対象: 該当チャンネルを閲覧しているユーザー
// + `id`: 変化したチャンネルのId
// + `viewers`: 変化後の閲覧者(配列)
// + `userId`: ユーザーId
// + `state`: 閲覧状態
// + `updatedAt`: 閲覧状態の更新日時
// ### `CHANNEL_SUBSCRIBERS_CHANGED`
// チャンネルの購読者が変化した。
// 対象: 該当チャンネルを閲覧しているユーザー
// + `id`: 変化したチャンネルのId
// ### `MESSAGE_CREATED`
// メッセージが投稿された。
// 対象:
// 投稿チャンネルを閲覧しているユーザー・投稿チャンネルに通知をつけているユーザー・メンションを受けたユーザー
// + `id`: 投稿されたメッセージのId
// + `is_citing`:
// 投稿されたメッセージがWebSocketを接続しているユーザーの投稿を引用しているかどうか
// ### `MESSAGE_UPDATED`
// メッセージが更新された。
// 対象: 投稿チャンネルを閲覧しているユーザー
// + `id`: 更新されたメッセージのId
// ### `MESSAGE_DELETED`
// メッセージが削除された。
// 対象: 投稿チャンネルを閲覧しているユーザー
// + `id`: 削除されたメッセージのId
// ### `MESSAGE_STAMPED`
// メッセージにスタンプが押された。
// 対象: 投稿チャンネルを閲覧しているユーザー
// + `message_id`: メッセージId
// + `user_id`: スタンプを押したユーザーのId
// + `stamp_id`: スタンプのId
// + `count`: そのユーザーが押した数
// + `created_at`:
// そのユーザーがそのスタンプをそのメッセージに最初に押した日時
// ### `MESSAGE_UNSTAMPED`
// メッセージからスタンプが外された。
// 対象: 投稿チャンネルを閲覧しているユーザー
// + `message_id`: メッセージId
// + `user_id`: スタンプを押したユーザーのId
// + `stamp_id`: スタンプのId
// ### `MESSAGE_PINNED`
// メッセージがピン留めされた。
// 対象: 投稿チャンネルを閲覧しているユーザー
// + `message_id`: ピンされたメッセージのID
// + `channel_id`: ピンされたメッセージのチャンネルID
// ### `MESSAGE_UNPINNED`
// ピン留めされたメッセージのピンが外された。
// 対象: 投稿チャンネルを閲覧しているユーザー
// + `message_id`: ピンが外されたメッセージのID
// + `channel_id`: ピンが外されたメッセージのチャンネルID
// ### `MESSAGE_READ`
// 自分があるチャンネルのメッセージを読んだ。
// 対象: 自分
// + `id`: 読んだチャンネルId
// ### `STAMP_CREATED`
// スタンプが新しく追加された。
// 対象: 全員
// + `id`: 作成されたスタンプのId
// ### `STAMP_UPDATED`
// スタンプが修正された。
// 対象: 全員
// + `id`: 修正されたスタンプのId
// ### `STAMP_DELETED`
// スタンプが削除された。
// 対象: 全員
// + `id`: 削除されたスタンプのId
// ### `STAMP_PALETTE_CREATED`
// スタンプパレットが新しく追加された。
// 対象: 自分
// + `id`: 作成されたスタンプパレットのId
// ### `STAMP_PALETTE_UPDATED`
// スタンプパレットが修正された。
// 対象: 自分
// + `id`: 修正されたスタンプパレットのId
// ### `STAMP_PALETTE_DELETED`
// スタンプパレットが削除された。
// 対象: 自分
// + `id`: 削除されたスタンプパレットのId
// ### `CLIP_FOLDER_CREATED`
// クリップフォルダーが作成された。
// 対象：自分
// + `id`: 作成されたクリップフォルダーのId
// ### `CLIP_FOLDER_UPDATED`
// クリップフォルダーが修正された。
// 対象: 自分
// + `id`: 更新されたクリップフォルダーのId
// ### `CLIP_FOLDER_DELETED`
// クリップフォルダーが削除された。
// 対象: 自分
// + `id`: 削除されたクリップフォルダーのId
// ### `CLIP_FOLDER_MESSAGE_DELETED`
// クリップフォルダーからメッセージが除外された。
// 対象: 自分
// + `folder_id`: メッセージが除外されたクリップフォルダーのId
// + `message_id`: クリップフォルダーから除外されたメッセージのId
// ### `CLIP_FOLDER_MESSAGE_ADDED`
// クリップフォルダーにメッセージが追加された。
// 対象: 自分
// + `folder_id`: メッセージが追加されたクリップフォルダーのId
// + `message_id`: クリップフォルダーに追加されたメッセージのId
// ### `QALL_ROOM_STATE_CHANGED`
// ルーム状態が変更された。
// 対象: 全員
// + `room_id`: 変更されたルームのId
// + `state`: 変更後のルーム状態
// + `roomId`: ルームのID
// + `participants`: ルーム内の参加者(配列)
// + `identity`: ユーザーID_RandomUUID
// + `name`: 表示名
// + `joinedAt`: 参加した時刻
// + `attributes`: ユーザーに関連付けられたカスタム属性
// + `canPublish`: 発言権限
// + `isWebinar`: ウェビナールームかどうか
// + `metadata`: ルームに関連付けられたカスタム属性
// ### `QALL_SOUNDBOARD_ITEM_CREATED`
// サウンドボードアイテムが作成された。
// 対象: 全員
// + `sound_id`: 作成されたサウンドのId
// + `name`: サウンド名
// + `creator_id`: 作成者のId
// ### `QALL_SOUNDBOARD_ITEM_DELETED`
// サウンドボードアイテムが削除された。
// 対象: 全員
// + `sound_id`: 削除されたサウンドのId.
//
// GET /ws
func (c *Client) Ws(ctx context.Context) error {
	_, err := c.sendWs(ctx)
	return err
}

func (c *Client) sendWs(ctx context.Context) (res *WsSwitchingProtocols, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/ws"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityOAuth2(ctx, WsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"OAuth2\"")
			}
		}
		{

			switch err := c.securityBearerAuth(ctx, WsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BearerAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
