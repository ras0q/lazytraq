// Code generated by ogen, DO NOT EDIT.

package traqapi

import (
	"bytes"
	"fmt"
	"io"
	"mime"
	"net/http"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

func decodeActivateBotResponse(resp *http.Response) (res ActivateBotRes, _ error) {
	switch resp.StatusCode {
	case 202:
		// Code 202.
		return &ActivateBotAccepted{}, nil
	case 403:
		// Code 403.
		return &ActivateBotForbidden{}, nil
	case 404:
		// Code 404.
		return &ActivateBotNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeAddMessageStampResponse(resp *http.Response) (res AddMessageStampRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &AddMessageStampNoContent{}, nil
	case 400:
		// Code 400.
		return &AddMessageStampBadRequest{}, nil
	case 404:
		// Code 404.
		return &AddMessageStampNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeAddMyStarResponse(resp *http.Response) (res AddMyStarRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &AddMyStarNoContent{}, nil
	case 400:
		// Code 400.
		return &AddMyStarBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeAddMyUserTagResponse(resp *http.Response) (res AddMyUserTagRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserTag
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &AddMyUserTagBadRequest{}, nil
	case 409:
		// Code 409.
		return &AddMyUserTagConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeAddUserGroupAdminResponse(resp *http.Response) (res AddUserGroupAdminRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &AddUserGroupAdminNoContent{}, nil
	case 400:
		// Code 400.
		return &AddUserGroupAdminBadRequest{}, nil
	case 403:
		// Code 403.
		return &AddUserGroupAdminForbidden{}, nil
	case 404:
		// Code 404.
		return &AddUserGroupAdminNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeAddUserGroupMemberResponse(resp *http.Response) (res AddUserGroupMemberRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &AddUserGroupMemberNoContent{}, nil
	case 400:
		// Code 400.
		return &AddUserGroupMemberBadRequest{}, nil
	case 403:
		// Code 403.
		return &AddUserGroupMemberForbidden{}, nil
	case 404:
		// Code 404.
		return &AddUserGroupMemberNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeAddUserTagResponse(resp *http.Response) (res AddUserTagRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserTag
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &AddUserTagBadRequest{}, nil
	case 403:
		// Code 403.
		return &AddUserTagForbidden{}, nil
	case 404:
		// Code 404.
		return &AddUserTagNotFound{}, nil
	case 409:
		// Code 409.
		return &AddUserTagConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeChangeMyNotifyCitationResponse(resp *http.Response) (res ChangeMyNotifyCitationRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &ChangeMyNotifyCitationNoContent{}, nil
	case 400:
		// Code 400.
		return &ChangeMyNotifyCitationBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeChangeMyPasswordResponse(resp *http.Response) (res ChangeMyPasswordRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &ChangeMyPasswordNoContent{}, nil
	case 400:
		// Code 400.
		return &ChangeMyPasswordBadRequest{}, nil
	case 401:
		// Code 401.
		return &ChangeMyPasswordUnauthorized{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeChangeParticipantRoleResponse(resp *http.Response) (res ChangeParticipantRoleRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response QallParticipantResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &ChangeParticipantRoleBadRequest{}, nil
	case 401:
		// Code 401.
		return &ChangeParticipantRoleUnauthorized{}, nil
	case 500:
		// Code 500.
		return &ChangeParticipantRoleInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeChangeStampImageResponse(resp *http.Response) (res ChangeStampImageRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &ChangeStampImageNoContent{}, nil
	case 400:
		// Code 400.
		return &ChangeStampImageBadRequest{}, nil
	case 404:
		// Code 404.
		return &ChangeStampImageNotFound{}, nil
	case 413:
		// Code 413.
		return &ChangeStampImageRequestEntityTooLarge{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeChangeUserPasswordResponse(resp *http.Response) (res ChangeUserPasswordRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &ChangeUserPasswordNoContent{}, nil
	case 400:
		// Code 400.
		return &ChangeUserPasswordBadRequest{}, nil
	case 403:
		// Code 403.
		return &ChangeUserPasswordForbidden{}, nil
	case 404:
		// Code 404.
		return &ChangeUserPasswordNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeClipMessageResponse(resp *http.Response) (res ClipMessageRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ClippedMessage
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &ClipMessageBadRequest{}, nil
	case 404:
		// Code 404.
		return &ClipMessageNotFound{}, nil
	case 409:
		// Code 409.
		return &ClipMessageConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeConnectBotWSResponse(resp *http.Response) (res *ConnectBotWSSwitchingProtocols, _ error) {
	switch resp.StatusCode {
	case 101:
		// Code 101.
		return &ConnectBotWSSwitchingProtocols{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateBotResponse(resp *http.Response) (res CreateBotRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response BotDetail
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateBotBadRequest{}, nil
	case 409:
		// Code 409.
		return &CreateBotConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateChannelResponse(resp *http.Response) (res CreateChannelRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Channel
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateChannelBadRequest{}, nil
	case 403:
		// Code 403.
		return &CreateChannelForbidden{}, nil
	case 409:
		// Code 409.
		return &CreateChannelConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateClientResponse(resp *http.Response) (res CreateClientRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response OAuth2ClientDetail
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateClientBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateClipFolderResponse(resp *http.Response) (res CreateClipFolderRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ClipFolder
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateClipFolderBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreatePinResponse(resp *http.Response) (res CreatePinRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response MessagePin
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreatePinBadRequest{}, nil
	case 404:
		// Code 404.
		return &CreatePinNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateStampPaletteResponse(resp *http.Response) (res CreateStampPaletteRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response StampPalette
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateStampPaletteBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateUserResponse(resp *http.Response) (res CreateUserRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserDetail
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateUserBadRequest{}, nil
	case 403:
		// Code 403.
		return &CreateUserForbidden{}, nil
	case 409:
		// Code 409.
		return &CreateUserConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateUserGroupResponse(resp *http.Response) (res CreateUserGroupRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserGroup
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateUserGroupBadRequest{}, nil
	case 403:
		// Code 403.
		return &CreateUserGroupForbidden{}, nil
	case 409:
		// Code 409.
		return &CreateUserGroupConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeCreateWebhookResponse(resp *http.Response) (res CreateWebhookRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Webhook
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &CreateWebhookBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteBotResponse(resp *http.Response) (res DeleteBotRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteBotNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteBotForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteBotNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteClientResponse(resp *http.Response) (res DeleteClientRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteClientNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteClientForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteClientNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteClipFolderResponse(resp *http.Response) (res DeleteClipFolderRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteClipFolderNoContent{}, nil
	case 404:
		// Code 404.
		return &DeleteClipFolderNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteFileResponse(resp *http.Response) (res DeleteFileRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteFileNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteFileForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteFileNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteMessageResponse(resp *http.Response) (res DeleteMessageRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteMessageNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteMessageForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteMessageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteOgpCacheResponse(resp *http.Response) (res DeleteOgpCacheRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteOgpCacheNoContent{}, nil
	case 400:
		// Code 400.
		return &DeleteOgpCacheBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteStampResponse(resp *http.Response) (res DeleteStampRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteStampNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteStampForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteStampNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteStampPaletteResponse(resp *http.Response) (res DeleteStampPaletteRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteStampPaletteNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteStampPaletteForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteStampPaletteNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteUserGroupResponse(resp *http.Response) (res DeleteUserGroupRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteUserGroupNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteUserGroupForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteUserGroupNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteWebhookResponse(resp *http.Response) (res DeleteWebhookRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteWebhookNoContent{}, nil
	case 404:
		// Code 404.
		return &DeleteWebhookNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeDeleteWebhookMessageResponse(resp *http.Response) (res DeleteWebhookMessageRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &DeleteWebhookMessageNoContent{}, nil
	case 403:
		// Code 403.
		return &DeleteWebhookMessageForbidden{}, nil
	case 404:
		// Code 404.
		return &DeleteWebhookMessageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditBotResponse(resp *http.Response) (res EditBotRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditBotNoContent{}, nil
	case 400:
		// Code 400.
		return &EditBotBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditBotForbidden{}, nil
	case 404:
		// Code 404.
		return &EditBotNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditChannelResponse(resp *http.Response) (res EditChannelRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditChannelNoContent{}, nil
	case 400:
		// Code 400.
		return &EditChannelBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditChannelForbidden{}, nil
	case 404:
		// Code 404.
		return &EditChannelNotFound{}, nil
	case 409:
		// Code 409.
		return &EditChannelConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditChannelSubscribersResponse(resp *http.Response) (res EditChannelSubscribersRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditChannelSubscribersNoContent{}, nil
	case 400:
		// Code 400.
		return &EditChannelSubscribersBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditChannelSubscribersForbidden{}, nil
	case 404:
		// Code 404.
		return &EditChannelSubscribersNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditChannelTopicResponse(resp *http.Response) (res EditChannelTopicRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditChannelTopicNoContent{}, nil
	case 400:
		// Code 400.
		return &EditChannelTopicBadRequest{}, nil
	case 404:
		// Code 404.
		return &EditChannelTopicNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditClientResponse(resp *http.Response) (res EditClientRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditClientNoContent{}, nil
	case 400:
		// Code 400.
		return &EditClientBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditClientForbidden{}, nil
	case 404:
		// Code 404.
		return &EditClientNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditClipFolderResponse(resp *http.Response) (res EditClipFolderRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditClipFolderNoContent{}, nil
	case 400:
		// Code 400.
		return &EditClipFolderBadRequest{}, nil
	case 404:
		// Code 404.
		return &EditClipFolderNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditMeResponse(resp *http.Response) (res EditMeRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditMeNoContent{}, nil
	case 400:
		// Code 400.
		return &EditMeBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditMessageResponse(resp *http.Response) (res EditMessageRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditMessageNoContent{}, nil
	case 400:
		// Code 400.
		return &EditMessageBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditMessageForbidden{}, nil
	case 404:
		// Code 404.
		return &EditMessageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditMyUserTagResponse(resp *http.Response) (res EditMyUserTagRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditMyUserTagNoContent{}, nil
	case 400:
		// Code 400.
		return &EditMyUserTagBadRequest{}, nil
	case 404:
		// Code 404.
		return &EditMyUserTagNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditStampResponse(resp *http.Response) (res EditStampRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditStampNoContent{}, nil
	case 400:
		// Code 400.
		return &EditStampBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditStampForbidden{}, nil
	case 404:
		// Code 404.
		return &EditStampNotFound{}, nil
	case 409:
		// Code 409.
		return &EditStampConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditStampPaletteResponse(resp *http.Response) (res EditStampPaletteRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditStampPaletteNoContent{}, nil
	case 400:
		// Code 400.
		return &EditStampPaletteBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditStampPaletteForbidden{}, nil
	case 404:
		// Code 404.
		return &EditStampPaletteNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditUserResponse(resp *http.Response) (res EditUserRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditUserNoContent{}, nil
	case 400:
		// Code 400.
		return &EditUserBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditUserForbidden{}, nil
	case 404:
		// Code 404.
		return &EditUserNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditUserGroupResponse(resp *http.Response) (res EditUserGroupRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditUserGroupNoContent{}, nil
	case 400:
		// Code 400.
		return &EditUserGroupBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditUserGroupForbidden{}, nil
	case 404:
		// Code 404.
		return &EditUserGroupNotFound{}, nil
	case 409:
		// Code 409.
		return &EditUserGroupConflict{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditUserGroupMemberResponse(resp *http.Response) (res EditUserGroupMemberRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditUserGroupMemberNoContent{}, nil
	case 400:
		// Code 400.
		return &EditUserGroupMemberBadRequest{}, nil
	case 403:
		// Code 403.
		return &EditUserGroupMemberForbidden{}, nil
	case 404:
		// Code 404.
		return &EditUserGroupMemberNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditUserTagResponse(resp *http.Response) (res EditUserTagRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditUserTagNoContent{}, nil
	case 400:
		// Code 400.
		return &EditUserTagBadRequest{}, nil
	case 404:
		// Code 404.
		return &EditUserTagNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeEditWebhookResponse(resp *http.Response) (res EditWebhookRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &EditWebhookNoContent{}, nil
	case 400:
		// Code 400.
		return &EditWebhookBadRequest{}, nil
	case 404:
		// Code 404.
		return &EditWebhookNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetActivityTimelineResponse(resp *http.Response) (res GetActivityTimelineRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetActivityTimelineOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetActivityTimelineBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetBotResponse(resp *http.Response) (res GetBotRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetBotOK
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &GetBotForbidden{}, nil
	case 404:
		// Code 404.
		return &GetBotNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetBotIconResponse(resp *http.Response) (res GetBotIconRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/gif":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetBotIconOKImageGIF{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/jpeg":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetBotIconOKImageJpeg{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetBotIconOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetBotIconNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetBotLogsResponse(resp *http.Response) (res GetBotLogsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetBotLogsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &GetBotLogsForbidden{}, nil
	case 404:
		// Code 404.
		return &GetBotLogsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetBotsResponse(resp *http.Response) (res []Bot, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []Bot
			if err := func() error {
				response = make([]Bot, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Bot
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelResponse(resp *http.Response) (res GetChannelRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Channel
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetChannelNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelBotsResponse(resp *http.Response) (res GetChannelBotsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetChannelBotsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetChannelBotsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelPathResponse(resp *http.Response) (res GetChannelPathRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ChannelPath
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetChannelPathNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelPinsResponse(resp *http.Response) (res GetChannelPinsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetChannelPinsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetChannelPinsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelStatsResponse(resp *http.Response) (res GetChannelStatsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ChannelStats
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetChannelStatsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelSubscribersResponse(resp *http.Response) (res GetChannelSubscribersRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetChannelSubscribersOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &GetChannelSubscribersForbidden{}, nil
	case 404:
		// Code 404.
		return &GetChannelSubscribersNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelTopicResponse(resp *http.Response) (res GetChannelTopicRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ChannelTopic
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetChannelTopicNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelViewersResponse(resp *http.Response) (res GetChannelViewersRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetChannelViewersOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetChannelViewersNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetChannelsResponse(resp *http.Response) (res *ChannelList, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ChannelList
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetClientResponse(resp *http.Response) (res GetClientRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetClientOK
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &GetClientForbidden{}, nil
	case 404:
		// Code 404.
		return &GetClientNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetClientsResponse(resp *http.Response) (res []OAuth2Client, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []OAuth2Client
			if err := func() error {
				response = make([]OAuth2Client, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem OAuth2Client
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetClipFolderResponse(resp *http.Response) (res GetClipFolderRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response ClipFolder
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetClipFolderNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetClipFoldersResponse(resp *http.Response) (res []ClipFolder, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []ClipFolder
			if err := func() error {
				response = make([]ClipFolder, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ClipFolder
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetClipsResponse(resp *http.Response) (res GetClipsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetClipsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetClipsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetDirectMessagesResponse(resp *http.Response) (res GetDirectMessagesRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []Message
			if err := func() error {
				response = make([]Message, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Message
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			var wrapper GetDirectMessagesOKHeaders
			wrapper.Response = response
			h := uri.NewHeaderDecoder(resp.Header)
			// Parse "X-TRAQ-MORE" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-TRAQ-MORE",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXTRAQMOREVal bool
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToBool(val)
								if err != nil {
									return err
								}

								wrapperDotXTRAQMOREVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XTRAQMORE.SetTo(wrapperDotXTRAQMOREVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-TRAQ-MORE header")
				}
			}
			return &wrapper, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetDirectMessagesBadRequest{}, nil
	case 404:
		// Code 404.
		return &GetDirectMessagesNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetFileResponse(resp *http.Response) (res GetFileRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/octet-stream":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetFileOK{Data: bytes.NewReader(b)}
			var wrapper GetFileOKHeaders
			wrapper.Response = response
			h := uri.NewHeaderDecoder(resp.Header)
			// Parse "Content-Disposition" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "Content-Disposition",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotContentDispositionVal string
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToString(val)
								if err != nil {
									return err
								}

								wrapperDotContentDispositionVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.ContentDisposition.SetTo(wrapperDotContentDispositionVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse Content-Disposition header")
				}
			}
			return &wrapper, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &GetFileForbidden{}, nil
	case 404:
		// Code 404.
		return &GetFileNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetFileMetaResponse(resp *http.Response) (res GetFileMetaRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response FileInfo
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &GetFileMetaForbidden{}, nil
	case 404:
		// Code 404.
		return &GetFileMetaNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetFilesResponse(resp *http.Response) (res GetFilesRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []FileInfo
			if err := func() error {
				response = make([]FileInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FileInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			var wrapper GetFilesOKHeaders
			wrapper.Response = response
			h := uri.NewHeaderDecoder(resp.Header)
			// Parse "X-TRAQ-MORE" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-TRAQ-MORE",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXTRAQMOREVal bool
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToBool(val)
								if err != nil {
									return err
								}

								wrapperDotXTRAQMOREVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XTRAQMORE.SetTo(wrapperDotXTRAQMOREVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-TRAQ-MORE header")
				}
			}
			return &wrapper, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetFilesBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetLiveKitTokenResponse(resp *http.Response) (res GetLiveKitTokenRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response QallTokenResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetLiveKitTokenBadRequest{}, nil
	case 401:
		// Code 401.
		return &GetLiveKitTokenUnauthorized{}, nil
	case 500:
		// Code 500.
		return &GetLiveKitTokenInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMeResponse(resp *http.Response) (res *MyUserDetail, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response MyUserDetail
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMessageResponse(resp *http.Response) (res GetMessageRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Message
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetMessageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMessageClipsResponse(resp *http.Response) (res GetMessageClipsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetMessageClipsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetMessageClipsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMessageStampsResponse(resp *http.Response) (res GetMessageStampsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetMessageStampsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetMessageStampsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMessagesResponse(resp *http.Response) (res GetMessagesRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []Message
			if err := func() error {
				response = make([]Message, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Message
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			var wrapper GetMessagesOKHeaders
			wrapper.Response = response
			h := uri.NewHeaderDecoder(resp.Header)
			// Parse "X-TRAQ-MORE" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-TRAQ-MORE",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXTRAQMOREVal bool
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToBool(val)
								if err != nil {
									return err
								}

								wrapperDotXTRAQMOREVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XTRAQMORE.SetTo(wrapperDotXTRAQMOREVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-TRAQ-MORE header")
				}
			}
			return &wrapper, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetMessagesBadRequest{}, nil
	case 404:
		// Code 404.
		return &GetMessagesNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyChannelSubscriptionsResponse(resp *http.Response) (res []UserSubscribeState, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []UserSubscribeState
			if err := func() error {
				response = make([]UserSubscribeState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserSubscribeState
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyExternalAccountsResponse(resp *http.Response) (res []ExternalProviderUser, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []ExternalProviderUser
			if err := func() error {
				response = make([]ExternalProviderUser, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalProviderUser
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyIconResponse(resp *http.Response) (res GetMyIconRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/gif":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetMyIconOKImageGIF{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/jpeg":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetMyIconOKImageJpeg{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetMyIconOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetMyIconNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyNotifyCitationResponse(resp *http.Response) (res *GetNotifyCitation, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetNotifyCitation
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyQRCodeResponse(resp *http.Response) (res GetMyQRCodeRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetMyQRCodeOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "text/plain":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetMyQRCodeOKTextPlain{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMySessionsResponse(resp *http.Response) (res []LoginSession, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []LoginSession
			if err := func() error {
				response = make([]LoginSession, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem LoginSession
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyStampHistoryResponse(resp *http.Response) (res []StampHistoryEntry, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []StampHistoryEntry
			if err := func() error {
				response = make([]StampHistoryEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StampHistoryEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyStampRecommendationsResponse(resp *http.Response) (res []GetMyStampRecommendationsOKItem, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []GetMyStampRecommendationsOKItem
			if err := func() error {
				response = make([]GetMyStampRecommendationsOKItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetMyStampRecommendationsOKItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyStarsResponse(resp *http.Response) (res []uuid.UUID, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []uuid.UUID
			if err := func() error {
				response = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyTokensResponse(resp *http.Response) (res []ActiveOAuth2Token, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []ActiveOAuth2Token
			if err := func() error {
				response = make([]ActiveOAuth2Token, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ActiveOAuth2Token
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyUnreadChannelsResponse(resp *http.Response) (res []UnreadChannel, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []UnreadChannel
			if err := func() error {
				response = make([]UnreadChannel, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UnreadChannel
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyUserTagsResponse(resp *http.Response) (res []UserTag, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []UserTag
			if err := func() error {
				response = make([]UserTag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserTag
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetMyViewStatesResponse(resp *http.Response) (res []MyChannelViewState, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []MyChannelViewState
			if err := func() error {
				response = make([]MyChannelViewState, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem MyChannelViewState
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetOAuth2AuthorizeResponse(resp *http.Response) (res GetOAuth2AuthorizeRes, _ error) {
	switch resp.StatusCode {
	case 302:
		// Code 302.
		return &GetOAuth2AuthorizeFound{}, nil
	case 400:
		// Code 400.
		return &GetOAuth2AuthorizeBadRequest{}, nil
	case 403:
		// Code 403.
		return &GetOAuth2AuthorizeForbidden{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetOIDCUserInfoResponse(resp *http.Response) (res *OIDCUserInfo, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response OIDCUserInfo
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetOgpResponse(resp *http.Response) (res GetOgpRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Ogp
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetOgpBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetOnlineUsersResponse(resp *http.Response) (res []string, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []string
			if err := func() error {
				response = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetPinResponse(resp *http.Response) (res GetPinRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response MessagePin
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetPinNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetPublicUserIconResponse(resp *http.Response) (res GetPublicUserIconRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/gif":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetPublicUserIconOKImageGIF{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/jpeg":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetPublicUserIconOKImageJpeg{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetPublicUserIconOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetPublicUserIconNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetQallEndpointsResponse(resp *http.Response) (res GetQallEndpointsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response QallEndpointResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetQallEndpointsNotFound{}, nil
	case 500:
		// Code 500.
		return &GetQallEndpointsInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetRoomMetadataResponse(resp *http.Response) (res GetRoomMetadataRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response QallMetadataResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetRoomMetadataNotFound{}, nil
	case 500:
		// Code 500.
		return &GetRoomMetadataInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetRoomsResponse(resp *http.Response) (res GetRoomsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response QallRoomsListResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetRoomsNotFound{}, nil
	case 500:
		// Code 500.
		return &GetRoomsInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetServerVersionResponse(resp *http.Response) (res *Version, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Version
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetSoundboardListResponse(resp *http.Response) (res GetSoundboardListRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response SoundboardListResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 500:
		// Code 500.
		return &GetSoundboardListInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetStampResponse(resp *http.Response) (res GetStampRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Stamp
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetStampNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetStampImageResponse(resp *http.Response) (res GetStampImageRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/gif":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetStampImageOKImageGIF{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/jpeg":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetStampImageOKImageJpeg{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetStampImageOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/svg+xml":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetStampImageOKImageSvgXML{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetStampImageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetStampPaletteResponse(resp *http.Response) (res GetStampPaletteRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response StampPalette
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetStampPaletteNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetStampPalettesResponse(resp *http.Response) (res []StampPalette, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []StampPalette
			if err := func() error {
				response = make([]StampPalette, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StampPalette
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetStampStatsResponse(resp *http.Response) (res GetStampStatsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response StampStats
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetStampStatsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetStampsResponse(resp *http.Response) (res []StampWithThumbnail, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []StampWithThumbnail
			if err := func() error {
				response = make([]StampWithThumbnail, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem StampWithThumbnail
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetTagResponse(resp *http.Response) (res GetTagRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Tag
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetTagNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetThumbnailImageResponse(resp *http.Response) (res GetThumbnailImageRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/jpeg":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetThumbnailImageOKImageJpeg{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetThumbnailImageOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/svg+xml":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetThumbnailImageOKImageSvgXML{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &GetThumbnailImageForbidden{}, nil
	case 404:
		// Code 404.
		return &GetThumbnailImageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserResponse(resp *http.Response) (res GetUserRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserDetail
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserDMChannelResponse(resp *http.Response) (res GetUserDMChannelRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response DMChannel
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserDMChannelNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserGroupResponse(resp *http.Response) (res GetUserGroupRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserGroup
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserGroupNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserGroupAdminsResponse(resp *http.Response) (res GetUserGroupAdminsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetUserGroupAdminsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserGroupAdminsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserGroupMembersResponse(resp *http.Response) (res GetUserGroupMembersRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetUserGroupMembersOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserGroupMembersNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserGroupsResponse(resp *http.Response) (res []UserGroup, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []UserGroup
			if err := func() error {
				response = make([]UserGroup, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserGroup
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserIconResponse(resp *http.Response) (res GetUserIconRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/gif":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetUserIconOKImageGIF{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/jpeg":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetUserIconOKImageJpeg{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetUserIconOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserIconNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserSettingsResponse(resp *http.Response) (res *UserSettings, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserSettings
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserStatsResponse(resp *http.Response) (res GetUserStatsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response UserStats
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserStatsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUserTagsResponse(resp *http.Response) (res GetUserTagsRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetUserTagsOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetUserTagsNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetUsersResponse(resp *http.Response) (res GetUsersRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response GetUsersOKApplicationJSON
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetUsersBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetWebRTCStateResponse(resp *http.Response) (res WebRTCUserStates, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response WebRTCUserStates
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetWebhookResponse(resp *http.Response) (res GetWebhookRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Webhook
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetWebhookNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetWebhookIconResponse(resp *http.Response) (res GetWebhookIconRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "image/gif":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetWebhookIconOKImageGIF{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/jpeg":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetWebhookIconOKImageJpeg{Data: bytes.NewReader(b)}
			return &response, nil
		case ct == "image/png":
			reader := resp.Body
			b, err := io.ReadAll(reader)
			if err != nil {
				return res, err
			}

			response := GetWebhookIconOKImagePNG{Data: bytes.NewReader(b)}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 404:
		// Code 404.
		return &GetWebhookIconNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetWebhookMessagesResponse(resp *http.Response) (res GetWebhookMessagesRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []Message
			if err := func() error {
				response = make([]Message, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Message
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				var failures []validate.FieldError
				for i, elem := range response {
					if err := func() error {
						if err := elem.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						failures = append(failures, validate.FieldError{
							Name:  fmt.Sprintf("[%d]", i),
							Error: err,
						})
					}
				}
				if len(failures) > 0 {
					return &validate.Error{Fields: failures}
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			var wrapper GetWebhookMessagesOKHeaders
			wrapper.Response = response
			h := uri.NewHeaderDecoder(resp.Header)
			// Parse "X-TRAQ-MORE" header.
			{
				cfg := uri.HeaderParameterDecodingConfig{
					Name:    "X-TRAQ-MORE",
					Explode: false,
				}
				if err := func() error {
					if err := h.HasParam(cfg); err == nil {
						if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
							var wrapperDotXTRAQMOREVal bool
							if err := func() error {
								val, err := d.DecodeValue()
								if err != nil {
									return err
								}

								c, err := conv.ToBool(val)
								if err != nil {
									return err
								}

								wrapperDotXTRAQMOREVal = c
								return nil
							}(); err != nil {
								return err
							}
							wrapper.XTRAQMORE.SetTo(wrapperDotXTRAQMOREVal)
							return nil
						}); err != nil {
							return err
						}
					}
					return nil
				}(); err != nil {
					return res, errors.Wrap(err, "parse X-TRAQ-MORE header")
				}
			}
			return &wrapper, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &GetWebhookMessagesBadRequest{}, nil
	case 404:
		// Code 404.
		return &GetWebhookMessagesNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeGetWebhooksResponse(resp *http.Response) (res []Webhook, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response []Webhook
			if err := func() error {
				response = make([]Webhook, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Webhook
					if err := elem.Decode(d); err != nil {
						return err
					}
					response = append(response, elem)
					return nil
				}); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if response == nil {
					return errors.New("nil is invalid value")
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeInactivateBotResponse(resp *http.Response) (res InactivateBotRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &InactivateBotNoContent{}, nil
	case 403:
		// Code 403.
		return &InactivateBotForbidden{}, nil
	case 404:
		// Code 404.
		return &InactivateBotNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeLetBotJoinChannelResponse(resp *http.Response) (res LetBotJoinChannelRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &LetBotJoinChannelNoContent{}, nil
	case 400:
		// Code 400.
		return &LetBotJoinChannelBadRequest{}, nil
	case 403:
		// Code 403.
		return &LetBotJoinChannelForbidden{}, nil
	case 404:
		// Code 404.
		return &LetBotJoinChannelNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeLetBotLeaveChannelResponse(resp *http.Response) (res LetBotLeaveChannelRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &LetBotLeaveChannelNoContent{}, nil
	case 400:
		// Code 400.
		return &LetBotLeaveChannelBadRequest{}, nil
	case 403:
		// Code 403.
		return &LetBotLeaveChannelForbidden{}, nil
	case 404:
		// Code 404.
		return &LetBotLeaveChannelNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeLinkExternalAccountResponse(resp *http.Response) (res LinkExternalAccountRes, _ error) {
	switch resp.StatusCode {
	case 302:
		// Code 302.
		return &LinkExternalAccountFound{}, nil
	case 400:
		// Code 400.
		return &LinkExternalAccountBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeLoginResponse(resp *http.Response) (res LoginRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &LoginNoContent{}, nil
	case 302:
		// Code 302.
		return &LoginFound{}, nil
	case 400:
		// Code 400.
		return &LoginBadRequest{}, nil
	case 401:
		// Code 401.
		return &LoginUnauthorized{}, nil
	case 403:
		// Code 403.
		return &LoginForbidden{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeLogoutResponse(resp *http.Response) (res LogoutRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &LogoutNoContent{}, nil
	case 302:
		// Code 302.
		return &LogoutFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostDirectMessageResponse(resp *http.Response) (res PostDirectMessageRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Message
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &PostDirectMessageBadRequest{}, nil
	case 404:
		// Code 404.
		return &PostDirectMessageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostFileResponse(resp *http.Response) (res PostFileRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response FileInfo
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &PostFileBadRequest{}, nil
	case 411:
		// Code 411.
		return &PostFileLengthRequired{}, nil
	case 413:
		// Code 413.
		return &PostFileRequestEntityTooLarge{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostMessageResponse(resp *http.Response) (res PostMessageRes, _ error) {
	switch resp.StatusCode {
	case 201:
		// Code 201.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response Message
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &PostMessageBadRequest{}, nil
	case 404:
		// Code 404.
		return &PostMessageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostOAuth2AuthorizeResponse(resp *http.Response) (res PostOAuth2AuthorizeRes, _ error) {
	switch resp.StatusCode {
	case 302:
		// Code 302.
		return &PostOAuth2AuthorizeFound{}, nil
	case 400:
		// Code 400.
		return &PostOAuth2AuthorizeBadRequest{}, nil
	case 403:
		// Code 403.
		return &PostOAuth2AuthorizeForbidden{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostOAuth2AuthorizeDecideResponse(resp *http.Response) (res PostOAuth2AuthorizeDecideRes, _ error) {
	switch resp.StatusCode {
	case 302:
		// Code 302.
		return &PostOAuth2AuthorizeDecideFound{}, nil
	case 400:
		// Code 400.
		return &PostOAuth2AuthorizeDecideBadRequest{}, nil
	case 403:
		// Code 403.
		return &PostOAuth2AuthorizeDecideForbidden{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostOAuth2TokenResponse(resp *http.Response) (res PostOAuth2TokenRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response OAuth2Token
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &PostOAuth2TokenBadRequest{}, nil
	case 403:
		// Code 403.
		return &PostOAuth2TokenForbidden{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostSoundboardResponse(resp *http.Response) (res PostSoundboardRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response SoundboardUploadResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &PostSoundboardBadRequest{}, nil
	case 500:
		// Code 500.
		return &PostSoundboardInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostSoundboardPlayResponse(resp *http.Response) (res PostSoundboardPlayRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response SoundboardPlayResponse
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &PostSoundboardPlayBadRequest{}, nil
	case 401:
		// Code 401.
		return &PostSoundboardPlayUnauthorized{}, nil
	case 500:
		// Code 500.
		return &PostSoundboardPlayInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostWebRTCAuthenticateResponse(resp *http.Response) (res PostWebRTCAuthenticateRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response WebRTCAuthenticateResult
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &PostWebRTCAuthenticateBadRequest{}, nil
	case 503:
		// Code 503.
		return &PostWebRTCAuthenticateServiceUnavailable{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodePostWebhookResponse(resp *http.Response) (res PostWebhookRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &PostWebhookNoContent{}, nil
	case 400:
		// Code 400.
		return &PostWebhookBadRequest{}, nil
	case 404:
		// Code 404.
		return &PostWebhookNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeReadChannelResponse(resp *http.Response) (res *ReadChannelNoContent, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &ReadChannelNoContent{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRegisterFCMDeviceResponse(resp *http.Response) (res RegisterFCMDeviceRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RegisterFCMDeviceNoContent{}, nil
	case 400:
		// Code 400.
		return &RegisterFCMDeviceBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeReissueBotResponse(resp *http.Response) (res ReissueBotRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response BotTokens
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 403:
		// Code 403.
		return &ReissueBotForbidden{}, nil
	case 404:
		// Code 404.
		return &ReissueBotNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemoveMessageStampResponse(resp *http.Response) (res RemoveMessageStampRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemoveMessageStampNoContent{}, nil
	case 404:
		// Code 404.
		return &RemoveMessageStampNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemoveMyStarResponse(resp *http.Response) (res *RemoveMyStarNoContent, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemoveMyStarNoContent{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemoveMyUserTagResponse(resp *http.Response) (res RemoveMyUserTagRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemoveMyUserTagNoContent{}, nil
	case 403:
		// Code 403.
		return &RemoveMyUserTagForbidden{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemovePinResponse(resp *http.Response) (res RemovePinRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemovePinNoContent{}, nil
	case 400:
		// Code 400.
		return &RemovePinBadRequest{}, nil
	case 404:
		// Code 404.
		return &RemovePinNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemoveUserGroupAdminResponse(resp *http.Response) (res RemoveUserGroupAdminRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemoveUserGroupAdminNoContent{}, nil
	case 400:
		// Code 400.
		return &RemoveUserGroupAdminBadRequest{}, nil
	case 403:
		// Code 403.
		return &RemoveUserGroupAdminForbidden{}, nil
	case 404:
		// Code 404.
		return &RemoveUserGroupAdminNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemoveUserGroupMemberResponse(resp *http.Response) (res RemoveUserGroupMemberRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemoveUserGroupMemberNoContent{}, nil
	case 403:
		// Code 403.
		return &RemoveUserGroupMemberForbidden{}, nil
	case 404:
		// Code 404.
		return &RemoveUserGroupMemberNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemoveUserGroupMembersResponse(resp *http.Response) (res RemoveUserGroupMembersRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemoveUserGroupMembersNoContent{}, nil
	case 403:
		// Code 403.
		return &RemoveUserGroupMembersForbidden{}, nil
	case 404:
		// Code 404.
		return &RemoveUserGroupMembersNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRemoveUserTagResponse(resp *http.Response) (res RemoveUserTagRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RemoveUserTagNoContent{}, nil
	case 403:
		// Code 403.
		return &RemoveUserTagForbidden{}, nil
	case 404:
		// Code 404.
		return &RemoveUserTagNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRevokeClientTokensResponse(resp *http.Response) (res RevokeClientTokensRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RevokeClientTokensNoContent{}, nil
	case 404:
		// Code 404.
		return &RevokeClientTokensNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRevokeMySessionResponse(resp *http.Response) (res *RevokeMySessionNoContent, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RevokeMySessionNoContent{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRevokeMyTokenResponse(resp *http.Response) (res RevokeMyTokenRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &RevokeMyTokenNoContent{}, nil
	case 404:
		// Code 404.
		return &RevokeMyTokenNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeRevokeOAuth2TokenResponse(resp *http.Response) (res *RevokeOAuth2TokenOK, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		return &RevokeOAuth2TokenOK{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeSearchMessagesResponse(resp *http.Response) (res SearchMessagesRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		ct, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
		if err != nil {
			return res, errors.Wrap(err, "parse media type")
		}
		switch {
		case ct == "application/json":
			buf, err := io.ReadAll(resp.Body)
			if err != nil {
				return res, err
			}
			d := jx.DecodeBytes(buf)

			var response SearchMessagesOK
			if err := func() error {
				if err := response.Decode(d); err != nil {
					return err
				}
				if err := d.Skip(); err != io.EOF {
					return errors.New("unexpected trailing data")
				}
				return nil
			}(); err != nil {
				err = &ogenerrors.DecodeBodyError{
					ContentType: ct,
					Body:        buf,
					Err:         err,
				}
				return res, err
			}
			// Validate response.
			if err := func() error {
				if err := response.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return res, errors.Wrap(err, "validate")
			}
			return &response, nil
		default:
			return res, validate.InvalidContentType(ct)
		}
	case 400:
		// Code 400.
		return &SearchMessagesBadRequest{}, nil
	case 503:
		// Code 503.
		return &SearchMessagesServiceUnavailable{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeSetChannelSubscribeLevelResponse(resp *http.Response) (res SetChannelSubscribeLevelRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &SetChannelSubscribeLevelNoContent{}, nil
	case 400:
		// Code 400.
		return &SetChannelSubscribeLevelBadRequest{}, nil
	case 403:
		// Code 403.
		return &SetChannelSubscribeLevelForbidden{}, nil
	case 404:
		// Code 404.
		return &SetChannelSubscribeLevelNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeSetChannelSubscribersResponse(resp *http.Response) (res SetChannelSubscribersRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &SetChannelSubscribersNoContent{}, nil
	case 400:
		// Code 400.
		return &SetChannelSubscribersBadRequest{}, nil
	case 403:
		// Code 403.
		return &SetChannelSubscribersForbidden{}, nil
	case 404:
		// Code 404.
		return &SetChannelSubscribersNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeUnclipMessageResponse(resp *http.Response) (res UnclipMessageRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &UnclipMessageNoContent{}, nil
	case 404:
		// Code 404.
		return &UnclipMessageNotFound{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeUnlinkExternalAccountResponse(resp *http.Response) (res UnlinkExternalAccountRes, _ error) {
	switch resp.StatusCode {
	case 204:
		// Code 204.
		return &UnlinkExternalAccountNoContent{}, nil
	case 400:
		// Code 400.
		return &UnlinkExternalAccountBadRequest{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeUpdateRoomMetadataResponse(resp *http.Response) (res UpdateRoomMetadataRes, _ error) {
	switch resp.StatusCode {
	case 200:
		// Code 200.
		return &UpdateRoomMetadataOK{}, nil
	case 400:
		// Code 400.
		return &UpdateRoomMetadataBadRequest{}, nil
	case 401:
		// Code 401.
		return &UpdateRoomMetadataUnauthorized{}, nil
	case 500:
		// Code 500.
		return &UpdateRoomMetadataInternalServerError{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}

func decodeWsResponse(resp *http.Response) (res *WsSwitchingProtocols, _ error) {
	switch resp.StatusCode {
	case 101:
		// Code 101.
		return &WsSwitchingProtocols{}, nil
	}
	return res, validate.UnexpectedStatusCodeWithResponse(resp)
}
